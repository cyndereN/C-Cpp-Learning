// 1. 格式：引用的格式：数据类型& 引用名 = 变量名；
// 指针的格式：数据类型 * 变量名 = 指向的变量地址；

// 2. 本质：指针是一个实体，需要分配内存空间，引用只是变量的别名，不需要分配内存空间
// 引用的本质在c++的内部实现是一个指针常量

// 3. 初始化：需要为指针分配内存区域，而不需要为引用分配内存区域；使用引用一定要初始化，初始化后就不能再修改了。

// 4. 安全检查：引用可以防止野指针的出现 
// 使用指针前最好做类型检查，防止野指针的出现：指针为了不出现野指针也要初始化为NULL
// 指针可以指向一个变量的地址后，也可以指向别的变量地址，可以改变
// 由此可见，引用定义后不能修改，指针可以修改，所以使用引用相较于指针更安全

// 5. 作为参数时的不同：引用作为函数参数时，调用不会开辟内存空间，只是给变量取了个别名
// 指针作为函数参数时，调用时在32位系统会开辟4字节的空间，且传入的变量要+&
// 传指针的实质是传值，传递的值是指针的地址；传引用的实质是传地址，传递的是变量的地址

// 6. 自增含义：指针自增代表指向下一个空间，引用自增代表引用的变量值加1 

// 7. 级数：有多级指针，没有多级引用 

// 7. 访问方式：引用只能对数组的元素使用，不能对整个数组使用
// 指针可以指向整个数组

// 8. sizeof 大小：sizeof引用得到的是指向变量的大小，sizeof 指针得到的是指针本身的大小 


// 补充：
int& ref = a;
ref = 20; // 内部发现是引用，自动转换： *ref = 20, 找到它指向的那块内存的数据，将其改成20

int& test02() {
	static int a = 10;  // 静态变量，存放在全局区
	return a;
}
test02() = 1000;  // 2. 如果函数的返回值是引用，这个函数调用可以作为左值