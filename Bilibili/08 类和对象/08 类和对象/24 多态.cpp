// 静态多态：函数重载和运算符重载属于静态多态，复用函数名
// 动态多态：派生类和虚函数实现运行时多态

// 静态多台的函数地址早绑定 - 编译阶段确定
// 动态多态的函数地址晚绑定 - 运行阶段确定

// 动态多态满足条件：
// 1. 有继承关系
// 2. 子类重写父类虚函数

class Animal { 
	// 不加虚函数，空类，大小是1字节。
	// 实例化其实这是C++中空类占位问题。
	// 在C++中空类会占一个字节，这是为了让对象的实例能够相互区别。具体来说，空类同样可以被实例化，并且每个实例在内存中都有独一无二的地址，
	// 因此，编译器会给空类隐含加上一个字节，这样空类实例化之后就会拥有独一无二的内存地址。如果没有这一个字节的占位，那么空类就无所谓实例化了，
	// 因为实例化的过程就是在内存中分配一块地址。
	// *注意：当该空白类作为基类时，该类的大小就优化为0了，这就是所谓的空白基类最优化。
	
	
	
	// 加了virtual关键字，变成了4字节（类内部多了个指向虚函数表的指针）
public:
	// 虚函数 地址晚绑定
	virtual void speak() {
		cout << "动物在说话" << endl;
	}
};

class Cat :public Animal {
public:
	// 重写 函数返回值类型 函数名 参数列表完全相同

	// 自身的虚函数表换掉 会替换成子类的虚函数地址
	void speak() {
		cout << "猫在说话" << endl;
	}
};

// 地址早绑定 在编译阶段确定函数地址 一定会打出"动物在说话"
// 如果想执行让猫说话，需要在运行阶段绑定，解决：在void speak()前加virtual
void doSpeak(Animal& animal) {
	animal.speak();
}

void test01() {
	Cat cat;
	// 当父类的指针或者引用指向子类对象的时候，发生多态
	// 从cat的虚函数表中找cat说话的函数
	doSpeak(cat);// Animal &animal = cat;

}

// 构造函数不可以是虚函数，而析构函数可以是虚函数(delete时多态的链式调用)
// 在多态的时候，比如基类的指针指向派生类的对象，如果删除该指针delete []p，就会调用该指针指向的派生类析构函数，而派生类的析构函数又自动调用基类的析构函数，这样整个派生类的对象完全被释放。
// 如果析构函数不被声明成虚函数，会造成派生类对象析构不完全。