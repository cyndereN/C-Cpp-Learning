// 静态多态：函数重载和运算符重载属于静态多态，复用函数名
// 动态多态：派生类和虚函数实现运行时多态

// 静态多台的函数地址早绑定 - 编译阶段确定
// 动态多态的函数地址晚绑定 - 运行阶段确定

// 静态是overload，动态是override，应用override的方法是虚函数，实现override的方式是动态绑定

// 动态多态满足条件：
// 1. 有继承关系
// 2. 子类覆盖父类虚函数
// 3. 子类重写父类函数

// 当某个类声明了虚函数时，/编译阶段/编译器将为该类对象安插一个虚函数表指针，并为该类设置一张唯一的虚函数表，虚函数表中存放的是该类虚函数地址（静态区）。
// 运行期间通过虚函数表指针与虚函数表去确定该类虚函数的真正实现



class Animal { 
	// 不加虚函数，空类，大小是1字节。
	// 实例化其实这是C++中空类占位问题。
	// 在C++中空类会占一个字节，这是为了让对象的实例能够相互区别。具体来说，空类同样可以被实例化，并且每个实例在内存中都有独一无二的地址，
	// 因此，编译器会给空类隐含加上一个字节，这样空类实例化之后就会拥有独一无二的内存地址。如果没有这一个字节的占位，那么空类就无所谓实例化了，
	// 因为实例化的过程就是在内存中分配一块地址。
	// *注意：当该空白类作为基类时，该类的大小就优化为0了，这就是所谓的空白基类最优化。
	
	
	
	// 加了virtual关键字，变成了4字节（类内部多了个指向虚函数表的指针）
public:
	// 虚函数 地址晚绑定
	virtual void speak() {
		cout << "动物在说话" << endl;
	}
};

class Cat :public Animal {
public:
	// 重写 函数返回值类型 函数名 参数列表完全相同

	// 自身的虚函数表换掉 会替换成子类的虚函数地址
	void speak() {
		cout << "猫在说话" << endl;
	}
};

// 地址早绑定 在编译阶段确定函数地址 一定会打出"动物在说话"
// 如果想执行让猫说话，需要在运行阶段绑定，解决：在void speak()前加virtual
void doSpeak(Animal& animal) {
	animal.speak();
}

void test01() {
	Cat cat;
	// 当父类的指针或者引用指向子类对象的时候，发生多态
	// 从cat的虚函数表中找cat说话的函数
	doSpeak(cat);// Animal &animal = cat;

}



// https://blog.csdn.net/michaelhan3/article/details/82463874 Overwrite, Overload 和 Override区别

// Override一定要针对被声明virtual的父类函数，函数名，参数，常量性保持一致。