// 构成连通网的最小代价生成树称为最小生成树

// 1. Prim算法

//G为图， 一般设置为 全局变量；数组d为顶点与集合S的最短距离
Prim(G,d[]){
	初始化;
	for(循环n次){
		u = 使d[u]最小的还未被访问的顶点的标号;
		记u已被访问;
		for(从u出发能到达的所有顶点v){
			if(v未被访问&&以u为中介点使得v与集合S的最短距离d[v]更优]){
				将G[u][v]赋值给v与集合S的最短距离d[v]; 
			} 
		} 
	}
}

// 和Dijkstra算法一样，使用这种写法的复杂度是O(V^2)，其中邻接表实现的prim算法可以通过堆优化使时间复杂度降为 O(VlogV+E)。
// 另外，O(V^2)的复杂度也说明，尽量在图的顶点数目较少而边数较多的情况下（即稠密图上）使用prim算法。

// 2. Kruskal 算法
// 将加权无向图中的所有边进行排序，每次选取权值最小的边，判断边的两端点是否在已经加入
// 最小生成树（此处判断运用到了并查集）（如果加入，就找下一个权值最小边）直到构成最小生成树。

// O(ElogE)，适合稀疏图