# 图解设计模式

## 1. 适应设计模式

### 1.1 Iterator模式

![Iterator_Pattern](Iterator.png)

- 不管实现如何变化，都可以使用lterator

不用for循环，而使用Iterator模式的一个重要的理由：引入Iterator后可以将遍历与实现分离开来。
```java
while (it.hasNext()) {
    Book book =(Book)it.next();
    System.out.println(book.getName());
}
```

这里只使用了Iterator的hasNext()和next()，并没有调用BookShelf的方法。

即：这里的while循环并不依赖于BookShelf的实现。

- 难以理解抽象类和接口

不要只使用具体的类来解决问题，很容易导致类之间的强耦合，这些类也难以作为组件被再次利用。要优先使用抽象类和接口来解决问题。

- 不需要 DelIterator 
- 
在Java中，没有被使用的对象实例将会自动被删除（垃圾回收，GC)。因此，在iterator中不需要与其对应的deleteIterator方法。

### 1.2 Adapter模式：加个“适配器”以便于复用

![Adapter](Adapter.png)

- 什么时候使用Adapter模式
如果某个方法就是我们所需要的方法，那么直接在程序中使用不就可以了吗？为什么还要考虑使用Adapter模式呢？

很多时候，我们并非从零开始编程，经常会用到现有的类。特别是当现有的类已经被充分测试过了，Bug很少，而且已经被用于其他软件之中时，我们更愿意将这些类作为组件重复利用。

Adapter模式会对现有的类进行适配，生成新的类。通过该模式可以很方便地创建我们需要的方法群。

当出现Bug时，由于我们很明确地知道Bug不在现有的类(Adaptee角色）中，所以只需调查扮演Adapter角色的类即可，方便排查代码问题。

使用Adapter模式可以在完全不改变现有代码的前提下使现有代码适配于新的接口(API)。

![Adapter_Example](Adapter_Example.png)

- 版本升级与兼容性

例如，假设我们今后只想维护新版本。这时可以让新版本扮演Adaptee角色，旧版本扮演Target角色。接着编写一个扮演Adapter角色的类，让它使用新版本的类来实现旧版本的类中的方法。
