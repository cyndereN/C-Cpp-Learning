# 大话设计模式

## 0. 设计原则

设计原则

- 单一职责原则（Single Responsibility Principle，SRP）：修改一个类的原因只有一个。
- 开闭原则（Open-Closed Principle，OCP）：对于扩展类应该开放，对于修改类应该封闭。
- 迪米特法则（Law of Demeter，LoD）：也叫最少知识原则，类应尽量降低成员的访问权限，即耦合尽可能弱。
- 依赖倒置原则（Dependency Inversion Principle，DIP）：高层次的类不应依赖低层次的类，都应依赖于抽象接口。
- 里氏替换原则（Liskov Substituion Principle，LSP）：扩展一个类时，能够（不修改代码）将子类的对象作为父类对象进行传递。和依赖倒置原则意思接近。

此外，还有下面常见的设计原则：

- 接口隔离原则（Interface Segregation Principle，ISP）：尽量缩小接口范围，让客户端不必实现不用的方法。和迪米特法则接近。
- 合成/聚合复用原则（Composite/Aggragate Reuse Principle，CARP）：尽量通过合成/聚合而不是继承达到复用目的。

## 1. 简单工厂

### 1.1 结构组成

简单工厂模式由三类主要角色组成：

1. 抽象类：定义所有支持算法的公共接口，在这个例子中具体运算抽象类；
2. 具体算法类：具体的算法，在这个例子中具体为加减乘除运算类；
3. 简单工厂类：维护对运算类的应用。

### 1.2 适用场景

将类类比为产品，则使用者可以在不清楚类生产的具体过程的情况下，使用不同的产品。

解决对象创建的问题，隔离客户端与具体类。

## 2. 策略模式

### 2.1 结构组成

策略模式由三类主要角色组成：

1. 策略类：定义所有支持算法的公共接口，在这个例子中具体为收费抽象类；
2. 具体策略类：具体的算法，在这个例子中具体为各类收费类和折扣优惠收费类；
3. 上下文类：维护对策略对象的应用。


### 2.2 适用场景

一个系统中有多个算法和类很相似，区分这些类和算法的只是其内部行为。

解决行为/算法扩展问题，避免用大量if-else切换算法。

### 2.3 实际应用

在导航应用中，有不同的路径规划算法，如针对步行的、骑行的、搭乘公共交通工具的、以及开车的等。主要导航类的主要工作是在地图上渲染出规划好的路径，并不会在意是由和算法生成的路径。此时可以将路径规划算法使用策略模式进行封装，方便与主要导航类的交互。

### 2.4 优点缺点

策略模式的优点有

- 可以以相同的方式调用所有算法，减少了各种算法类与使用算法类之间的耦合。策略模式的Strategy类层次为Context类定义了一系列的可供重复使用的算法或行为，继承有助于析取这些算法中的公共功能。
- 简化了单元测试。每个算法都有自己的类，可以通过自己的接口单独测试；
- 符合“开放封闭原则”，无需对上下文进行修改就可以引入新的策略。

策略模式的缺点有

- 不适合算法极少发生改变的场景，会使得程序整体过于复杂；
- 要求客户端必须知晓策略间的不同，因为需要从中选择。


## 3. 单一职责原则

单一职责原则，The Single Responsibility Principle，简称 SRP，是指就一个类而言，应该仅有一个更改它的原因。也即这个类只有一个职责。

**使用动机**

若不遵守单一职责原则，即一个类有一个以上的职责，则当一个职责发生变化时，可能会影响其他职责，从而影响代码的维护。

**如何使用**

核心在于职责的分解。需要将相同的职责放到一起，不同的职责分开到不同的类的实现中去。具体来说，对于一个类，如果能想到多于一个的动机去改变一个类，那么该类具有多于一个的职责，应该考虑将类的职责分解。

**使用原则**

- 每一个类实现的职责有清晰明确的定义。
- 一个类的修改只对自身有影响，对其他类没有影响。

**使用示例**

以一个俄罗斯方块游戏为例。

最直观的想法是，用一个计时器控制动画，每一个计时器编写绘制和擦除方块的逻辑，模拟下落时方块形状的变化，再做一个堆积和消层的判断，最后提供键盘控制逻辑。

假设我们一开始做的是 Web 游戏，游戏效果不错后需要增加 3D 版、手机版等。此时，相对变化的只有方块的样式，但由于我们的代码都在一块，导致其他不变的逻辑没法复用。这就是职责过多的情况，接下来考虑如何将职责分解。

最简单的方法就是将变化的和相对不变的部分分开，也就是将游戏的逻辑（不变的部分）和界面的展示（易变的部分）分开。具体来说，可以将游戏区域设计为二维数组，通过坐标来表示每个方块，实际显示出的方块就是坐标值为 1 的方块。这样，就可以通过值为 1 的坐标的变化模拟出方块的堆积和变换。也就是说，游戏的操作和判断逻辑（如变换、移动、堆积、消层等）其实就是坐标值的变化。界面的展示只是根据数组数据进行绘制。


## 4. 开放-封闭原则

开闭原则，The Open-Closed Principle，简称 OCP，是指软件实体（类、模块、函数等）应该可以扩展，但是不可以修改。即对于扩展是开放的，对于更改是封闭的。通俗来说就是对于要增加的新功能或要调整的改动，尽量扩展新代码而不是修改已有代码。

**使用动机**

面对需求改变可以保持相对稳定，使得系统可以在第一个版本以后不断推出新的版本。

**如何使用**

通过对以下可能时机的变化，创建抽象，隔离以后发生的同类变化。

- 在开发工作展开前预测可能的变化。

- 或展开不久后知道可能发生的变化。

- 或当实际需要发生时带来的变化。

**使用原则**

- 仅对程序中呈现出频繁变化的部分做出抽象。
- 不要刻意对每个部分进行抽象，拒绝不成熟的抽象，它和抽象本身一样重要。


**使用示例**

以一个加法器为例。

当我们在接到这个需求时，就可以很容易地想到以后可能需要减法、乘法、除法等等运算。所以，我们在开发的时候就可以先把「加法」抽象成一个类，这样，以后需要其他运算时，只要增加一个类即可。

实际做的时候我们可能会发现用户输入的可能是个表达式，不一定是两个数字，有可能是三个数字，还有可能有括号。这时候我们可能会写一个四则混合运算解析器类。以后如果需要解析其他表达式（如复数），则只需增加对应的类。

好不容易做完了，突然又来了新需求，需要做一个字符串的加法（即拼接），我们假设 API 不变。此时，我们可能需要设计一个输入表达式判断器类，用于判断是数字还是字符串的运算。我们还需要对原来的代码进行一些调整，以便 API 进来的输入能够首先通过判断器。

## 5. 依赖倒转原则

依赖倒置原则，Dependence Inversion Principle，简称 DIP，是指程序不应该依赖细节，细节应该依赖于抽象。简单来说，就是要针对接口编程，不要针对实现编程。

**使用动机**

面对不同的具体实现做到易拔插，松耦合。

**如何使用**

- 使用接口或抽象类的目的是制定好规范，不涉及任何具体的操作，把展现细节的任务交给实现类去完成。
- 让程序中的所有依赖关系都终止于抽象类或接口。

**使用原则**

- 高层模块不应该依赖低层模块，两个都应该依赖抽象。
- 抽象不应该依赖细节，细节应该依赖抽象。

**使用示例**

以计算机为例。

刚开始的计算机是自成体系的，虽然都是采用同样的设计架构和结构，但组件之间的连接方式不同。如果用 A 公司的电脑，硬盘坏了后只能用 A 公司提供的硬盘。这是一种紧耦合的表现，每个组件将其内部实现暴露给外部对接。

后来几家大公司统一了标准，约定好组件之间连接的标准，标准后面具体怎么做，由相应公司自己负责。这样的结果是，我们既可以使用 A 公司的硬盘，也可以使用 B 公司的硬盘。不光如此，不同大小（如 500G 和 200G）、不同结构（如固态硬盘和机械硬盘）的硬盘也可以互换。真正实现了可拔插、易拔插。

除了硬盘，其他如 CPU、内存、外设设备等各种设备组件也都实现了标准化接口。所有的对接都发生在接口层面，不需要关心具体的实现细节。


## 6. 装饰模式

装饰模式（Decorator Pattern）是指创建一个装饰类，来包装原有的类，从而实现动态地向一个现有的对象添加一些额外的职责，同时不改变其原有的结构。装饰模式比生成子类更为灵活。

### 6.1 结构组成

装饰模式由四类主要角色组成：

1. 实体接口：对象接口的定义，可以为对象动态添加职责，在这个例子中职责具体为形象展示的过程，由于Person类在此程序中只有形象展示这一个职责，Person类既是访问接口，也是实体类；
2. 实体类：在这个例子中具体为Person类；
3. 装饰抽象类：继承实体接口，动态扩展其职责，在这个例子中具体为服饰抽象类；
4. 具体装饰类：装饰的具体实现，在这个例子中具体为各类服饰类，如大T恤，大垮裤等。

### 6.2 **适用场景**

可以在不生成很多子类的情况下扩展类，适用于扩展类需求较多，而又不想引起子类膨胀的场景。

### 6.3 **实际应用**

通知信息有多种渠道，如通过短信、微信、QQ、邮件等。不同的信息会采用不同的多种渠道组合进行通知，此时若对每一个组合都建立子类，会造成子类数量爆炸，可以考虑装饰器模式。

### 6.4 **优点缺点**

装饰模式的优点有

- 把类中的装饰功能从类中搬移去除，很好地简化了原有的类；
- 有效地把类的核心职责和装饰功能区分开了，可以去除相关类中重复的装饰逻辑；
- 装饰类和被装饰类可以独立发展，不会相互耦合；
- 无需创建新子类即可实现对类功能的动态扩展；
- 支持运行时添加或删除对象的功能；
- 满足“单一职责原则”，可将实现许多不同行为的类拆分为多个较小的类。

装饰模式的缺点有

- 在封装器栈中删除特定封装器比较困难；
- 较难实现行为不受到先后顺序影响的装饰；
- 各装饰层的代码相对冗余。

## 7. 代理模式

### 7.1 **适用场景**

不方便直接访问对象时，为不宜直接访问的对象提供一个访问层。

当你需要控制或增强对某个对象的访问时（如延迟加载、权限控制、缓存等），代理模式是理想选择。

使用代理模式的方式分为以下几种：

- 本地执行远程服务（远程代理）：适用于服务对象位于远程服务器上的情形，可以为一个对象在不同的地址空间提供局部代表。
- 延迟初始化（虚拟代理）：如果你有一个偶尔使用的重量级服务对象，一直保持该对象运行会消耗系统资源时，可使用代理模式。
- 访问控制（保护代理/安全代理）：如果只希望特定客户端使用服务对象，对象可以是操作系统中的重要部分，而客户端则是各种已启动程序，可使用代理模式。
- 记录日志请求（日志记录代理）：适用于需要保存对于服务对象的请求历史记录时。
- 缓存请求结果（缓存代理）：适用于需要缓存客户请求结果并对缓存生命周期进行管理时，特别是返回结果体积非常大时。
- 智能指引：调用真实对象时，代理处理另外一些事，可在没有客户端使用某个重量级对象时，立刻销毁该对象。

### 7.2 **实际应用**

- 信用卡是银行账户的代理，而银行账户则是一大捆现金的代理。它们都可以实现相同的支付功能。
- windows里的快捷方式。
- 客户端对数据库的查询有时要消耗大量系统资源，常在有需要时才创建（延迟初始化），这会带来代码的大量重复。可以创建代理，让代理伪装成数据库对象，在客户端或实际数据库对象不知情的情况下处理延迟初始化和缓存查询结果的工作。

### 7.3 **优点缺点**

模式优点包括：

- 引入代理后，职责清晰；
- 引入代理后，可扩展多种用途，如：
    - 远程代理可以隐藏一个对象存在于不同地址空间的事实。
    - 虚拟代理可以存放实例化时间很长的真实对象。
- 符合“开放封闭原则”，无需对服务器或客户端进行修改就创建新的代理。

模式缺点包括：

- 代码可能变得复杂，因为需要新建许多类；
- 服务响应可能会延迟。

## 8. 工厂方法模式

简单工厂：

- 工厂类职责过重，新增产品时需要修改工厂类代码（违反开闭原则）。

- 不支持动态扩展，每增加一个产品就要改工厂逻辑。

### 8.1 **适用场景**

有明确的根据不同条件创造实例的计划时。将类类比为产品，产品具有系列/组合的形式，则使用者可以在不清楚类生产的具体过程及一个系列/组合的类包含的具体内容的情况下，使用一个系列的产品。

有以下几类适合场景

- 无法预知对象确切类别及其依赖关系时，工厂方法能将创建产品的代码与实际使用产品的代码分离，从而能在不影响其他代码的情况下扩展产品创建的部分。
- 希望用户能扩展软件库/框架的内部组件。

### 8.2 **实际应用**

- 向一个已有多种运输方式（如卡车等）的物流应用新增一种运输方式：轮船。


### 8.3 **优点缺点**

工厂方法模式的优点包括

- 可以避免创建者和具体产品之间的紧密耦合；
- 扩展性高，如果想增加一个新的产品，只需要扩展一个工厂类就可以；
- 符合“开放封闭原则”，无需更改现有工厂类代码，就可以引入新的功能；
- 符合“单一职责原则”，可以将产品创建代码放在程序的单一位置，从而使得代码更容易维护。

工厂方法模式的缺点包括

- 代码可能变得复杂，因为需要引入许多类。

## 9. 原型模式

### 9.1 **适用场景**

实际项目中，原型模式很少单独出现。一般和工厂方法模式一起出现，通过Clone创建对象，然后由工厂方法提供给调用者。

- 直接创建对象的代价较大时，常采用原型模式，可提升性能；
- new一个对象需要非常繁琐的数据准备或访问权限；
- 一个对象多个修改者的场景。

一般在初始化信息不发生变化的情况下，克隆是较好的方法。它既隐藏了对象创建的细节，又提升了性能。

### 9.2 **优点缺点**

优点：

- 提高性能；
- 逃避构造函数的约束。

缺点：

- 需要对类的功能进行通盘考虑，对于已有的类不一定很容易。特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候；
- 必须实现Cloneable接口。

## 10. 模板方法模式

把不变的行为搬到超类，去除子类中的重复代码。

### 10.1 结构组成

- AbstractClass：抽象类，也就是一个抽象模板，定义并实现了一个模板方法。这个模板方法一般是一个具体方法，给出了顶级逻辑的骨架；
- ConcreteClass：子类，实现父类所定义的一个或多个抽象方法。每一个ConcreteClass都可以给出抽象方法的不同实现。

### 10.2 **适用场景**

- 有多个子类共有的方法，且逻辑相同；
- 重要的、复杂的方法，可以考虑作为模板方法。

### 10.3 **实际应用**

- Spring 中对 Hibernate 的支持，将一些已经定好的方法封装起来，比如开启事务、获取 Session、关闭 Session 等，程序员不重复写那些已经规范好的代码，直接丢一个实体就可以保存；
- 在造房子的时候，地基、走线、水管都一样，只有在建筑的后期才有加壁橱加栅栏等差异；

### 10.4 优点缺点

优点：

- 把不变的形为搬到超类，去除了子类中的重复代码，提供了很好的代码复用平台，便于维护；
- 封装不变部分，扩展可变部分；
- 行为由父类控制，子类实现；

缺点： 

- 每一个不同的实现都需要一个子类实现，导致类的个数增加，使得系统更加庞大。

## 11. 迪米特法则

Law of Demeter，简称 LoD，也叫最小知识原则。是指如果两个类不必彼此互相通信，那么这两个类就不应当发生直接的相互作用；如果其中一个类需要调用另一个类的某一个方法，可以通过第三者转发这个调用。

### 11.1 使用动机

强调类之间的松耦合。类之间的耦合越弱，越有利于复用和扩展。另外，一个处于弱耦合的类被修改，不会对有关系的类造成波及。

### 11.2 如何使用

- 在类的结构设计上，每一个类都应当尽量降低成员的访问权限，不需要让别的类知道的字段或行为就不要公开。
- 类之间不直接建立联系，通过中间类来中转。

### 11.3 使用原则

- 减少公开方法和变量。
- 每个类对其他类知道的越少越好。
- 类不应该知道它所操作的对象的内部细节。

### 11.4 使用示例

以跨部门办事为例。

假设我们电脑出问题了，第一反应是找运维部门的熟人帮忙看看，这等于直接操作了运维部门的内部。这样的好处几乎没有，但问题很多。也许有人会说都找到人直接解决问题了，不是很高效吗，其实并不是。首先，你找熟人时，他不一定有时间，也许手里还有更重要、更紧急的事情在忙；其次，他也许也不知道你的问题，或者说他不负责这一块，无能为力；还有，如果他人际关系不错，很多人出问题了都来找他，还会导致部门内工作不均衡；另外，他自己一直在解决问题，但是领导却并不知晓，即便知道也不能接受。总而言之，如果都去找熟人，最后效率和满意度都不会很高。

这时候最好的做法是提供一个运维部门的问题反馈入口，由这名同事将收集到的问题分门别类，统一分派给部门内相应的人员进行处理。这样不仅资源得到了均衡，而且还易于批量解决问题，领导查看也一目了然。即便有同事请假，那也是运维部门内部的事情，由内部自己解决，并不影响外部使用。

## 12. 外观模式（Facade）

### 12.1 结构组成

外观类，需要了解所有子系统的方法或属性，进行组合，以便外界调用。

- SubSystem: 子系统的类；
- Facade：外观类，需要了解所有子系统的方法或属性，进行组合，以备外界调用；
- Client：客户端调用。由于Facade的存在，客户端不需要知道三个子系统类的存在。

### 12.2 适用场景
客户端不需要知道系统内部的复杂联系，整个系统只需提供一个"接待员"即可

### 12.3 实际应用

- 三层开发模式
    - 设计初期，在层与层直接建立外观模式；
    - 开发阶段，子系统经常因为不断的重构变得更复杂。外观模式可以提供加简单的接口，方便外部调用；
    - 维护遗留的大系统时，为新系统开发一个外观模式，让新系统与Facade对象交互，Facade与遗留代码交互。
- 医院看病，挂号、门诊、划价、取药，让患者觉得很复杂。设有接待人员，就很方便。

### 12.4 优点缺点

优点：
- 减少了系统间的相互依赖
- 提高了灵活性

缺点：

- 不符合开闭原则。如果要改东西很麻烦，继承和重写都不合适。

## 13. 建造者模式

### 13.1 适用场景

创建一些复杂的对象，这些对象内部构建间的建造顺序通常是稳定的，但对象内部的构建通常面临着复杂的变化；
一些基础部件不变，而其组合经常变化。

### 13.2 实际应用
- JAVA中的StringBuilder
- 去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的"套餐"；


### 13.3 优点缺点

优点：

- 使得建造代码与表示代码分离，易扩展
- 便于控制细节风险

缺点：

- 产品必须有共同点，范围有限制
- 如内部变化复杂，会有很多的建造类

## 14. 观察者模式

### 14.1 适用场景

当一个对象的改变需要同时改变多个（不知道具体数目）对象时。就比如例子中的员工数，多少个都可以。
当一个抽象模型的两个方面一方依赖于另一方时，将两者封装在独立的对象中。

### 14.2 实际应用

实际中的例子：批量自动更新。

- RSS 之类的订阅应用。比如订阅了大牛的博客，大牛更新博客后会自动将其同步到阅读器。
- 消息、通知类应用。比如微信公众号，关注后有新消息发布就推送到我们的手机上。
- 竞拍、股票类应用。比如炒股工具，当一支股票价格发生变化时，我们手里的软件会自动更新波动。


### 14.3 优点缺点

观察者模式优点包括：

- Subject 和 Observer 之间松耦合，可以轻松扩展。而且两者都可以扩展，不会对系统造成影响。
- 支持广播通信，不需要指定接收者，而且可以随时增删 Observer。

观察者模式缺点包括：

- 不同的订阅者可能需要不同的更新（功能），而不是所有的都一样。比如炒股的可能要切换桌面，而看 NBA 的既要切换桌面还得关掉声音。
- Subject 依赖于 Observer 对抽象接口的实现，没有实现就无法更新。比如炒股的没有实现更新方法，那他的摸鱼行为自然就要暴露了。

## 15. 抽象工厂

和工厂方法区别： 针对 多个产品族（如“汽车+引擎+轮胎”）

### 15.1 适用场景

- 需要使用大量工厂方法生产系列产品时。比如上面例子中的多个数据库。
- 需要独立于产品的创建、组合和表示时。
- 需要将产品类库的接口和实现分离时。比如上面例子中的两张表。

### 15.2 实际应用

实际中的例子：极少扩展的产品系列。

- 数据库。
- 标准用户界面工具包。
- 汽车部件。
- 游戏环境。

### 15.3 优点缺点

抽象工厂模式优点包括：

- 将产品和生成产品分开，工厂不同，产品不同，易于维护。
- 具体实例创建与客户端解耦，客户端不关心具体工厂。

抽象工厂模式缺点包括：

- 难以支持新种类的产品，因为扩展新类需要扩展工厂接口，涉及到所有子类的改变。比如我们新增了一张 Project 表，那就需要在所有地方都实现一遍。