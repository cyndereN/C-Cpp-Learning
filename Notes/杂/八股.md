## 1. STL六大组件

- Container(容器)：各种数据结构，如Vector,List,Deque,Set,Map,用来存放数据，STL容器是一种Class Template,就体积而言，这一部分很像冰山载海面的比率。

- Adapter(适配器)：一种用来修饰容器（Containers）或仿函数（Functors）或迭代器（Iterators）接口的东西，例如：STL提供的Queue和Stack，虽然看似容器，其实只能算是一种容器配接器，因为 它们的底部完全借助Deque，所有操作有底层的Deque供应。改变Functor接口者，称为Function Adapter;改变Container接口者，称为Container Adapter;改变Iterator接口者，称为Iterator Adapter。配接器的实现技术很难一言蔽之，必须逐一分析。

- Algorithm(算法)：各种常用算法如Sort,Search,Copy,Erase,从实现的角度来看，STL算法是一种Function Templates。

- Iterator(迭代器)：扮演容器与算法之间的胶合剂，是所谓的“泛型指针”，共有五种类型，以及其它衍生变化，从实现的角度来看，迭代器是一种将：Operators*,Operator->,Operator++,Operator--等相关操作予以重载的Class Template。所有STL容器都附带有自己专属的迭代器——是的，只有容器设计者才知道如何遍历自己的元素，原生指针（Native pointer）也是一种迭代器。

- Function object(函数对象)：行为类似函数，可作为算法的某种策略（Policy），从实现的角度来看，仿函数是一种重载了Operator()的Class 或 Class Template。一般函数指针可视为狭义的仿函数。

- Allocator(分配器)：负责空间配置与管理，从实现的角度来看，配置器是一个实现了动态空间配置、空间管理、空间释放的Class Template。


## 2. 红黑树删除节点原理

红黑树（Red Black Tree）是一颗自平衡（self-balancing）的二叉排序树（BST），树上的每一个结点都遵循下面的规则（特别提醒，这里的自平衡和平衡二叉树AVL的高度平衡有别）：

1. 每一个结点都有一个颜色，要么为红色，要么为黑色；
2. 树的根结点为黑色；
3. 树中不存在两个相邻的红色结点（即红色结点的父结点和孩子结点均不能是红色）；
4. 从任意一个结点（包括根结点）到其任何后代 NULL 结点（默认是黑色的）的每条路径都具有相同数量的黑色结点。

- 为什么要有红黑树？

    大多数二叉排序树BST的操作（查找、最大值、最小值、插入、删除等等）都是 O(h) 的时间复杂度，h 为树的高度。
    但是对于斜树而言（BST极端情况下出现），BST的这些操作的时间复杂度将达到  O(n)。
    为了保证BST的所有操作的时间复杂度的上限为 O(logn) ，就要想办法把一颗BST树的高度一直维持在 logn. 而红黑树就做到了这一点，红黑树的高度始终都维持在 logn ，n 为树中的顶点数目.

- 红黑树RBT与平衡二叉树AVL比较：

    AVL 树比红黑树更加平衡，但AVL树在插入和删除的时候也会存在大量的旋转操作。所以当你的应用涉及到频繁的插入和删除操作，切记放弃AVL树，选择性能更好的红黑树；当然，如果你的应用中涉及的插入和删除操作并不频繁，而是查找操作相对更频繁，那么就优先选择 AVL 树进行实现。

- 一颗红黑树是如何保持平衡的？
    https://cloud.tencent.com/developer/article/1794165

引理：一棵有n个内部结点的红黑树的高度 h <= 2lg(n+1)。

## 3. 听说过右值引用吗，说一下功能

C++11 之前，只有 copy 语意，这对于极度关注性能的语言而言是一个重大的缺失。那时候程序员为了避免性能损失， 只好采取规避的方式。比如:

```cpp
std::string str = s1;
str += s2;
```

这种写法就可以规避不必要的拷贝。而更加直观的写法：

```cpp
std::string str = s1 + s2;
```

则必须忍受一个 s1 + s2 所导致的中间 临时对象 到 str 的拷贝开销。 即便那个中间临时对象随着表达式的结束，会被销毁（更糟的是，销毁所伴随的资源释放，也是一种性能开销）。

对于 move 语意的急迫需求，到了 C++11 终于被引入。其直接的驱动力很简单：在构造或者赋值时， 如果等号右侧是一个中间临时对象，应直接将其占用的资源直接 move 过来（对方就没有了）。

详情看Rvalue.md以及Understanding Modern C++。

## 4. 说一说new和malloc的区别

1. 属性的区别

    new/delete：这两个是C++中的关键字，若要使用，需要编译器支持；

    malloc/free：这两个是库函数，若要使用则需要引入相应的头文件才可以正常使用。

2. 使用上的区别

    malloc：申请空间需要显式填入申请内存的大小；

    new：无需显式填入申请的内存大小，new会根据new的类型分配内存。

    ```cpp
    /** malloc/free用例 **/
    int* ma = (int*) malloc(4)；
    free(ma)；
    /** new/delete用例 **/
    int* ne = newint(0);
    ```

3. 内存位置的区别

    new：此操作符分配的内存空间是在自由存储区(free store)；

    malloc：申请的内存是在堆空间。

    C/C++的内存通常分为：堆、栈、自由存储区、全局/静态存储区、常量存储区。可能除了自由存储区，其他的内存分布大家应该都比较熟悉。

    堆 是C语言和操作系统的术语，堆是操作系统所维护的一块特殊内存，它提供了动态分配的功能，当运行程序调用malloc()时就会从中分配，调用free()归还内存。那什么是自由存储区呢？

    自由存储区 是C++中动态分配和释放对象的一个概念，通过new分配的内存区域可以称为自由存储区，通过delete释放归还内存。自由存储区可以是堆、全局/静态存储区等，具体是在哪个区，主要还是要看new的实现以及C++编译器默认new申请的内存是在哪里。但是基本上，很多C++编译器默认使用堆来实现自由存储，运算符new和delete内部默认是使用malloc和free的方式来被实现，说它在堆上也对，说它在自由存储区上也正确。因为在C++中new和delete符号是可以重载的，我们可以重新实现new的实现代码，可以让其分配的内存位置在静态存储区等。而malloc和free是C里的库函数，无法对其进行重载。

4. 返回类型的区别

    new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void*，需要通过强制类型转换将void*指针转换成我们需要的类型。所以在C++程序中使用new会比malloc安全可靠。

5. 分配失败情况的区别

    malloc分配内存失败时返回NULL，我们可以通过判断返回值可以得知是否分配成功；

    new内存分配失败时，会抛出bad_alloc异常，它不会返回NULL，分配失败时如果不捕捉异常，那么程序就会异常退出，我们可以通过异常捕捉的方式获取该异常。

6. 定义对象系统调度过程的区别

    使用new操作符来分配对象内存时会经历三个步骤：

    调用operator new 函数（对于数组是operator new[]）分配一块足够的内存空间（通常底层默认使用malloc实现，除非程序员重载new符号）以便存储特定类型的对象；

    编译器运行相应的构造函数以构造对象，并为其传入初值。

    对象构造完成后，返回一个指向该对象的指针。

    使用delete操作符来释放对象内存时会经历两个步骤：

    调用对象的析构函数。

    编译器调用operator delete(或operator delete[])函数释放内存空间（通常底层默认使用free实现，除非程序员重载delete符号）。

    自己可以通过实例去验证下，此处就不展开例程了。

7. 扩张内存大小的区别

    malloc：使用malloc分配内存后，发现内存不够用，那我们可以通过realloc函数来扩张内存大小，realloc会先判断当前申请的内存后面是否还有足够的内存空间进行扩张，如果有足够的空间，那么就会往后面继续申请空间，并返回原来的地址指针；否则realloc会在另外有足够大小的内存申请一块空间，并将当前内存空间里的内容拷贝到新的内存空间里，最后返回新的地址指针。

    new：new没有扩张内存的机制。


## 5. 引用占内存吗

一般C++的教材中都是这么定义的：

1. 引用就是一个对象的别名。
2. 引用不是值不占内存空间。
3. 引用必须在定义时赋值，将变量与引用绑定。

这里给出引用的本质定义

1. 引用实际是通过指针实现的。
2. 引用是一个指针常量。
3. 引用在内存中占4个字节(占用内存和cpu位数有关系 64位系统是8个字节)。因为指针存的是地址，所以和地址总线的位数有关。
4. 在对引用定义时，需要对这个常量指针初始化。

引用只是编译器之上，给出来的一个抽象定义。接口的实现，由编译器来决定！

引用不占空间意思就是不占对象空间，不表示不占指针的少量空间。实际上指针是汇编工具实现引用的一种方式而已，而有的优化结果可能没有代表自己的指针。

总而言之，引用就是引用，是这种概念，它为方便程序员使用，和方便汇编工具优化而产生。汇编怎么实现和优化是汇编的事，至于出了什么违反该概念的结果，是汇编的错，而不是定义的错，不要本末倒置。

## 6. 手写一个智能指针

考察面试人员的基本功（考察类的写法，构造\拷贝构造\赋值\移动构造\运算符重载等）。

1. Shared_ptr

注意:

- 对于构造函数，我们仿照了shared_ptr的源代码，加入了explicit关键字，防止原始指针隐式的转化为智能指针。
- 传入空指针或者使用默认构造函数时，引用计数为0。
- 拷贝赋值函数需要检查自赋值的情况。
- 释放动态内存时时刻注意两个指针是不是空指针。

- Shared_ptr将一个计数器与类指向的对象相关联，引用计数跟踪该类有多少个对象共享同一指针。每次创建类的新对象时，初始化指针并将引用计数置为1；

- 当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数；

- 对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数；

- 调用析构函数时，构造函数减少引用计数（如果引用计数减至0，则自动删除所指向的堆内存；

```cpp
template<typename T>
class SharedPtr()
{
public:
    explicit SharedPtr();
    explicit SharedPtr(T *_ptr);
    SharedPtr(const SharedPtr& p);  // 拷贝构造函数
    // 拷贝赋值运算符(左边的值减少，右边的值增加)
    SharedPtr& operator=(const SharedPtr& p);
    ~SharedPtr();

    
    // 解引用运算符
    T& operator*();
    // 箭头运算符
    T* operator->();
    // 重载布尔值操作
    operator bool();

    T* get() const;

    size_t use_count();

    bool isUnique();

    void swap(SharedPtr& p);

private:
    size_t* count;
    T* ptr;
};

template<typename T>
SharedPtr<T>::SharedPtr() : count(new size_t(0)), ptr(nullptr)
{}

template<typename T>
SharedPtr<T>::SharedPtr(T *_ptr) : count(new size_t(1)), ptr(_ptr)
{}

template<typename T>
SharedPtr<T>::~SharedPtr()
{
    --(*count);
    if(*count <= 0) {
        delete ptr;
        delete count;
        ptr = nullptr;
        count = nullptr;
    }
    std::cout << "Shared ptr destroyed." << std::endl;
}

template<typename T>
SharedPtr<T>::SharedPtr(const SharedPtr &p)
{
    count = p.count;
    ptr = p.ptr;
    ++(*count);
}

template<typename T>
SharedPtr<T>& SharedPtr<T>::operator=(const SharedPtr &p)
{
    // 如果是原指针，直接返回
    if(ptr == p.ptr) {
        return *this;
    }

    if(ptr) {
        --(*count);
        if((*count) == 0) {
            delete ptr;
            delete count;
        }
    }

    ptr = p.ptr;
    count = p.count;
    ++(*count);
    return *this;
}

template<typename T>
T& SharedPtr<T>::operator*()
{
    return *ptr;
}

template<typename T>
T* SharedPtr<T>::operator->()
{
    return ptr;
}

template<typename T>
SharedPtr<T>::operator bool()
{
    return ptr != nullptr;
}

template<typename T>
T* SharedPtr<T>::get() const
{
    return ptr;
}

template<typename T>
size_t SharedPtr<T>::use_count()
{
    return *count;
}

template<typename T>
bool SharedPtr<T>::isUnique()
{
    return *count == 1;
}

template<typename T>
void SharedPtr<T>::swap(SharedPtr& p)
{
    std::swap(*this, p);
}

```

2. Unique_ptr

- unique_ptr“唯一”拥有其所指对象，同一时刻只能有一个unique_ptr指向给定对象（通过禁止拷贝语义、只有移动语义来实现）。相比与原始指针unique_ptr用于其RAII的特性，使得在出现异常的情况下，动态资源能得到释放。

- unique_ptr指针本身的生命周期：从unique_ptr指针创建时开始，直到离开作用域。离开作用域时，若其指向对象，则将其所指对象销毁(默认使用delete操作符，用户可指定其他操作)。

- unique_ptr指针与其所指对象的关系：在智能指针生命周期内，可以改变智能指针所指对象，如创建智能指针时通过构造函数指定、通过reset方法重新指定、通过release方法释放所有权、通过移动语义转移所有权。


3. Weak_ptr

- weak_ptr是一种不控制对象生命周期的智能指针，它指向一个 shared_ptr 管理的对象。进行该对象的内存管理的是那个强引用的 shared_ptr，weak_ptr只是提供了对管理对象的一个访问手段。

- weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作，它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。


7. 流水线与冒险

Pipeline Hazards
https://zhuanlan.zhihu.com/p/447682231


8. Shared_ptr循环引用的例子? 

Boy类中有Girl的智能指针；
Girl类中有Boy的智能指针；
当他们交叉互相持有对方的管理对象;

```cpp
#include <iostream>
#include <string>
#include <memory>

using namespace std;

class Girl;

class Boy {
public:
	Boy() {
		cout << "Boy 构造函数" << endl;
	}

	~Boy() {
		cout << "~Boy 析构函数" << endl;
	}

	void setGirlFriend(shared_ptr<Girl> _girlFriend) {
		this->girlFriend = _girlFriend;
	}

private:
	shared_ptr<Girl> girlFriend;
};

class Girl {
public:
	Girl() {
		cout << "Girl 构造函数" << endl;
	}

	~Girl() {
		cout << "~Girl 析构函数" << endl;
	}

	void setBoyFriend(shared_ptr<Boy> _boyFriend) {
		this->boyFriend = _boyFriend;
	}

private:
	shared_ptr<Boy> boyFriend;
};


void useTrap() {
	shared_ptr<Boy> spBoy(new Boy());
	shared_ptr<Girl> spGirl(new Girl());

	// 陷阱用法
	spBoy->setGirlFriend(spGirl);
	spGirl->setBoyFriend(spBoy);
	// 此时boy和girl的引用计数都是2
}


int main(void) {
	useTrap();

	system("pause");
	return 0;
}
```

程序结束了，但是并没有释放内存，这是为什么呢？？？
useTrap函数结束后，函数中定义的智能指针被清掉，boy和girl指针的引用计数减1，还剩下1，对象中的智能指针还是托管他们的，所以函数结束后没有将boy和gilr指针释放的原因就是于此。

有办法解决的，那就是使用weak_ptr弱指针。

另一种情况。如果是单方获得管理对方的共享指针，那么这样着是可以正常释放掉的！

```cpp
void useTrap() {
	shared_ptr<Boy> spBoy(new Boy());
	shared_ptr<Girl> spGirl(new Girl());

	// 单方获得管理
	//spBoy->setGirlFriend(spGirl);
	spGirl->setBoyFriend(spBoy);	
}
```

首先释放spBoy，但是因为girl对象里面的智能指针还托管着boy，boy的引用计数为2，所以释放spBoy时，引用计数减1，boy的引用计数为1；

在释放spGirl，girl的引用计数减1，为零，开始释放girl的内存，因为girl里面还包含有托管boy的智能指针对象，所以也会进行boyFriend的内存释放，boy的引用计数减1，为零，接着开始释放boy的内存。最终所有的内存都释放了。


```cpp
weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。 同时weak_ptr 没有重载*和->但可以使用 lock 获得一个可用的 shared_ptr 对象。

弱指针的使用；

```cpp
weak_ptr wpGirl_1; // 定义空的弱指针

weak_ptr wpGirl_2(spGirl); // 使用共享指针构造

wpGirl_1 = spGirl; // 允许共享指针赋值给弱指针

// 弱指针也可以获得引用计数；

wpGirl_1.use_count()

// 弱指针不支持 * 和 -> 对指针的访问；
```

在必要的使用可以转换成共享指针 lock()；

```cpp
shared_ptr<Girl> sp_girl;
sp_girl = wpGirl_1.lock();

// 使用完之后，再将共享指针置NULL即可
sp_girl = NULL;
```


```cpp
#include <iostream>
#include <string>
#include <memory>

using namespace std;

class Girl;

class Boy {
public:
	Boy() {
		cout << "Boy 构造函数" << endl;
	}

	~Boy() {
		cout << "~Boy 析构函数" << endl;
	}

	void setGirlFriend(shared_ptr<Girl> _girlFriend) {
		this->girlFriend = _girlFriend;


		// 在必要的使用可以转换成共享指针
		shared_ptr<Girl> sp_girl;
		sp_girl = this->girlFriend.lock();

		cout << sp_girl.use_count() << endl;
		// 使用完之后，再将共享指针置NULL即可
		sp_girl = NULL;
	}

private:
	weak_ptr<Girl> girlFriend;
};

class Girl {
public:
	Girl() {
		cout << "Girl 构造函数" << endl;
	}

	~Girl() {
		cout << "~Girl 析构函数" << endl;
	}

	void setBoyFriend(shared_ptr<Boy> _boyFriend) {
		this->boyFriend = _boyFriend;
	}

private:
	shared_ptr<Boy> boyFriend;
};


void useTrap() {
	shared_ptr<Boy> spBoy(new Boy());
	shared_ptr<Girl> spGirl(new Girl());

	spBoy->setGirlFriend(spGirl);
	spGirl->setBoyFriend(spBoy);
}


int main(void) {
	useTrap();

	system("pause");
	return 0;
}

/*
Boy 构造函数
Girl 构造函数
3
~Girl 析构函数
~Boy 析构函数
*/
```

expired：判断当前weak_ptr智能指针是否还有托管的对象，有则返回false，无则返回true

如果返回true，等价于 use_count() == 0，即已经没有托管的对象了；当然，可能还有析构函数进行释放内存，但此对象的析构已经临近（或可能已发生）。

```cpp
#include <iostream>
#include <memory>

std::weak_ptr<int> gw;

void f() {

	// expired：判断当前智能指针是否还有托管的对象，有则返回false，无则返回true
	if (!gw.expired()) {
		std::cout << "gw is valid\n";	// 有效的，还有托管的指针
	} else {
		std::cout << "gw is expired\n";	// 过期的，没有托管的指针
	}
}

int main() {
	{
		auto sp = std::make_shared<int>(42);
		gw = sp;

		f();
	}

	// 当{ }体中的指针生命周期结束后，再来判断其是否还有托管的指针
	f();

	return 0;
}

/*
gw is valid
gw is expired
*/
```


## 9. Vector自动扩容、缩容?

和数组类似，也称为单端数组

不同之处在于数组是静态空间，vector可以动态扩展

动态扩展：并不是在原空间后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间

vector 的迭代器支持随机访问


// 头部插入删除：O(N)

// 尾部插入删除:O(1)

// 中间插入删除：O(N)

// 查找：O(N)

在C++标准库容器vector的容量是不会自动的缩减的，也就是说删除元素操作，其引用、指针、迭代器也会继续有效。那么当在一个较大的vector中删除了大量的元素之后，其实际的size比较小，而其capacity比较大，如果对空间比较敏感，希望vector的容量能够缩小一些，这时可以使用下面的技巧来实现。

```cpp
std::vector<T> tmp(v);
tmp.swap(v);
```

```cpp
std::vector<T>(v1).swap(v1);
```

## 10. 生产者-消费者问题

生产者消费者问题（英語：Producer-consumer problem），也称有限缓冲问题（Bounded-buffer problem），是一个多进程同步问题的经典案例。 该问题描述了共享固定大小缓冲区的两个进程——即所谓的“生产者”和“消费者”——在实际运行时会发生的问题。

- 单生产者和单消费者

    有两个进程：一组生产者进程和一组消费者进程共享一个初始为空、固定大小为n的缓存（缓冲区）。生产者的工作是制造一段数据，只有缓冲区没满时，生产者才能把消息放入到缓冲区，否则必须等待，如此反复; 同时，只有缓冲区不空时，消费者才能从中取出消息，一次消费一段数据（即将其从缓存中移出），否则必须等待。由于缓冲区是临界资源，它只允许一个生产者放入消息，或者一个消费者从中取出消息。

    **问题的核心**是：

        1.要保证不让生产者在缓存还是满的时候仍然要向内写数据;

        2.不让消费者试图从空的缓存中取出数据。

    生产者和消费者对缓冲区互斥访问是互斥关系，同时生产者和消费者又是一个相互协作的关系，只有生产者生产之后，消费者才能消费，他们也是同步关系。

    **解决思路**：对于生产者，如果缓存是满的就去睡觉。消费者从缓存中取走数据后就叫醒生产者，让它再次将缓存填满。若消费者发现缓存是空的，就去睡觉了。下一轮中生产者将数据写入后就叫醒消费者。不完善的解决方案会造成“死锁”，即两个进程都在“睡觉”等着对方来“唤醒”。

    只有生产者和消费者两个进程，正好是这两个进程存在着互斥关系和同步关系。那么需要解决的是互斥和同步PV操作的位置。使用“进程间通信”，“信号标”semaphore就可以解决唤醒的问题：

        我们使用了两个信号标：full 和 empty 。信号量mutex作为互斥信号量，它用于控制互斥访问缓冲池，互斥信号量初值为 1；信号量 full 用于记录当前缓冲池中“满”缓冲区数，初值为0。信号量 empty 用于记录当前缓冲池中“空”缓冲区数，初值为n。新的数据添加到缓存中后，full 在增加，而 empty 则减少。如果生产者试图在 empty 为0时减少其值，生产者就会被“催眠”。下一轮中有数据被消费掉时，empty就会增加，生产者就会被“唤醒”。

    ```cpp
    semaphore mutex=1; //临界区互斥信号量
    semaphore empty=n;  //空闲缓冲区
    semaphore full=0;  //缓冲区初始化为空
    producer ()//生产者进程 
    {
        while(1)
        {
            produce an item in nextp;  //生产数据
            P(empty);  //获取空缓冲区单元
            P(mutex);  //进入临界区.
            add nextp to buffer;  //将数据放入缓冲区
            V(mutex);  //离开临界区,释放互斥信号量
            V(full);  //满缓冲区数加1
        }
    }

    consumer ()//消费者进程
    {
        while(1)
        {
            P(full);  //获取满缓冲区单元
            P(mutex);  // 进入临界区
            remove an item from buffer;  //从缓冲区中取出数据
            V (mutex);  //离开临界区，释放互斥信号量
            V (empty) ;  //空缓冲区数加1
            consume the item;  //消费数据
        }
    }
    ```

    该类问题要注意对缓冲区大小为n的处理，当缓冲区中有空时便可对empty变量执行P 操作，一旦取走一个产品便要执行V操作以释放空闲区。对empty和full变量的P操作必须放在对mutex的P操作之前。


## 11. Cpp 在Linux中的内存布局，为什么BSS段每次都要清零

BSS段我所知道的起源是Unix最初的时候（当然，不排除可能有更早的情况）。变量分两种：局部变量、全局变量。

根据C语法的规定，局部变量不设置初始值的时候，其初始值是不确定的，局部变量（不含静态局部变量）的存储位置位于栈上，具体位置不固定。

全局变量（和静态局部变量）有专门数据段存储，初始值是0，具体位置是固定的。

其实说到底，就两种，一种是位置固定（数据段里），一种是位置不固定的（栈上）。 

要知道，早期的计算机存储设备是很贵的，而很多时候，数据段里的全局变量都是0（或者没有初始值），那么存储这么多的0到目标文件里其实是没有必要的。所以为了节约空间，在生成目标文件的时候，就把没有初始值（实际就是0）的数据段里的变量都放到BSS段里，这样目标文件就不需要那么大的体积里（节约磁盘空间）。只有当目标文件被载入的时候，加载器负责把BSS段清零（一个循环就可以搞定）。 之后，这个规则慢慢的成为一个标准配置，大多数编译器也就都支持了BSS段。

解释几个问题：

- Q:为什么局部变量初始值不是0？ 
    
    A:局部变量初始值也可以是零（在某些语言中就是），但这实际上需要消耗硬件指令去完成，有些时候这种清零的动作意义不大，对于编译器来说也是一种负担，每次调用函数都要消耗指令去清零，负担太大。要知道全局变量在内存中只有一份，局部变量（非静态）可以是多份的，前者一次清零就可以了，后者多次清零，负担太大。 

    C语言中，未初始化的局部变量到底是多少？

    答案往往是：

        - 与编译器有关。
        - 可能但不保证初始化为0。
        - 未确定。

    CPU不认识变量，更无法识别变量的名字，CPU只会从特定的内存位置取值或者将值存到特定的内存位置，因此当问一个变量的值是多少的时候，必须要知道这个变量对应的值被保存在什么地方。

    ```cpp
    #include <stdio.h>

    void func1()
    {
        int a;
        printf("func1:%d\n", a);
        a = 12345;
    }

    void func2()
    {
        int b;
        printf("func2:%d\n", b);
    }

    void func4()
    {
        int d;
        printf("func3:%d\n", d);
    }

    void func3()
    {
        int c;
        printf("func3:%d\n", c);
        c = 54321;
        func4();
    }

    void test_call()
    {
        func3();
    }

    int main(int argc, char **argv)
    {
        func1();
        func2();

        test_call();
    }

    ```

    **总结：函数返回在pop出当前栈帧的时候，并不会清理它遗留在栈帧里的数据，下个函数调用再次重用到该栈帧的内存时，未初始化的局部变量将会被遗留数据影响，从而变得不确定！**

    所以，记得初始化你的局部变量。

- Q: 如果BSS不清零可不可以？ 

    A: 可以，如果编译器规定BSS段不清零，也是可以的，但这样的话C语言语法就要改了：未初始化的全局变量和静态局部变量，其值是未知的。甚至其它语言也要跟着改语法。 

- Q: BSS段清零的原因是因为这个段是BSS 现在存储介质这么便宜了，是不是BSS已经没有必要了？

    A: 当然不是了，介质便宜仅限于PC和数码产品这一块，嵌入式行业永远都不存在存储介质没有限制的情况。

## 12. 一个没有成员变量的类，sizeof大小是多少？

sizeof(空类/空结构体) = 1；

空类，没有任何成员变量或函数，即没有存储任何内容；但是由于空类仍然可以实例化，例如：

```cpp
ClassA A;  
cout << "sizeof(A): " << sizeof(A) << endl; 
```

一个类能够实例化，编译器就需给它分配内存空间，来指示类实例的地址。这里编译器默认分配了一个字节（如：char. C char是1个字节，因为它是在标准中指定的, 最可能的逻辑是, char (标准字符集)的(二进制)表示可以适合1个字节。 在C的主要开发时，最常用的标准是ASCII和EBCDIC ，它们分别需要7位和8位编码。），以便标记可能初始化的类实例，同时使空类占用的空间也最少（即1字节）。这是被编译器安插进去的一个字节，这样就使得这个空类的两个实例得以在内存中配置独一无二的地址。


## 13. 什么是内存对齐？为什么要？C++怎么调整内存对齐大小？


1. 什么是内存对齐

    还是用一个例子带出这个问题，看下面的小程序，理论上，32位系统下，int占4byte，char占一个byte，那么将它们放到一个结构体中应该占4+1=5byte；但是实际上，通过运行程序得到的结果是8 byte，这就是内存对齐所导致的。

    ```cpp
    //32位系统
    #include<stdio.h>
    struct{
        int x;
        char y;
    }s;

    int main()
    {
        printf("%d\n",sizeof(s);  // 输出8
        return 0;
    }
    ```

    现代计算机中内存空间都是按照 byte 划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但是实际的计算机系统对基本类型数据在内存中存放的位置有限制，它们会要求这些数据的首地址的值是某个数k（通常它为4或8）的倍数，这就是所谓的内存对齐。

2. 为什么要进行内存对齐

    尽管内存是以字节为单位，但是大部分处理器并不是按字节块来存取内存的.它一般会以双字节,四字节,8字节,16字节甚至32字节为单位来存取内存，我们将上述这些存取单位称为内存存取粒度.

    现在考虑4字节存取粒度的处理器取int类型变量（32位系统），该处理器只能从地址为4的倍数的内存开始读取数据。

    假如没有内存对齐机制，数据可以任意存放，现在一个int变量存放在从地址1开始的连续四个字节地址中，该处理器去取数据时，要先从0地址开始读取第一个4字节块,剔除不想要的字节（0地址）,然后从地址4开始读取下一个4字节块,同样剔除不要的数据（5，6，7地址）,最后留下的两块数据合并放入寄存器.这需要做很多工作.

    现在有了内存对齐的，int类型数据只能存放在按照对齐规则的内存中，比如说0地址开始的内存。那么现在该处理器在取数据时一次性就能将数据读出来了，而且不需要做额外的操作，提高了效率。

3. 规则

    每个特定平台上的编译器都有自己的默认“对齐系数”（也叫对齐模数）。gcc中默认#pragma pack(4)，可以通过预编译命令#pragma pack(n)，n = 1,2,4,8,16来改变这一系数。

    有效对其值：是给定值#pragma pack(n)和结构体中最长数据类型长度中较小的那个。有效对齐值也叫对齐单位。

    了解了上面的概念后，我们现在可以来看看内存对齐需要遵循的规则：

    (1) 结构体第一个成员的偏移量（offset）为0，以后每个成员相对于结构体首地址的 offset 都是该成员大小与有效对齐值中较小那个的整数倍，如有需要编译器会在成员之间加上填充字节。

    (2) 结构体的总大小为 有效对齐值 的整数倍，如有需要编译器会在最末一个成员之后加上填充字节。

    ```cpp
    // 32位系统
    // Linux环境下进行的，linux下默认#pragma pack(4)，且结构体中最长的数据类型为4个字节，所以有效对齐单位为4字节
    #include<stdio.h>
    struct
    {
        int i;    
        char c1;  
        char c2;  
    }x1;

    struct{
        char c1;  
        int i;    
        char c2;  
    }x2;

    struct{
        char c1;  
        char c2; 
        int i;    
    }x3;

    int main()
    {
        printf("%d\n",sizeof(x1));  // 输出8
        printf("%d\n",sizeof(x2));  // 输出12
        printf("%d\n",sizeof(x3));  // 输出8
        return 0;
    }
    ```

## 14. 什么函数不能声明为virtual？为什么构造函数一定不能为virtual？有virtual方法的类，为什么析构函数一定是virtual？

在C++中，除了构造函数和静态成员函数，其他所有成员函数都可以声明为虚函数。

构造函数不能声明为虚函数，因为在创建对象时，必须知道对象的确切类型，以便正确地调用相应的构造函数。当类中声明虚函数时，编译器会在类中生成一个虚函数表，虚函数表是一个存储成员函数指针的数据结构。虚函数表是由编译器自动生成与维护的，virtual成员函数会被编译器放入虚函数表中，当存在虚函数时，每个对象都有一个指向虚函数的指针（vptr指针）。在实现多态的过程中，父类和派生类都有vptr指针。vptr的初始化：当对象在创建时，由编译器对vptr指针进行初始化。在定义子类对象时，vptr先指向父类的虚函数表，在父类构造完成之后，子类的vptr才指向自己的虚函数表。（也就是说当子类构造时，编译器会将父类的虚函数表复制到子类中。因此，子类构造完后，就会有父类的虚函数表。如果子类没有重写父类的任何虚函数，那么子类的虚函数表和父类的虚函数表完全相同。如果子类重写了父类的某些虚函数，那么子类的虚函数表会在重写的虚函数处进行修改。）如果构造函数是虚函数，那么调用构造函数就需要去找vptr，而此时vptr还没有初始化（还没到创建的时候呢）。因此，构造函数不可以是虚函数。

析构函数应该声明为虚函数，因为在使用基类指针指向派生类对象并删除基类指针时，如果析构函数不是虚拟的，只会调用基类的析构函数，而不会调用派生类的析构函数，这可能导致资源泄漏或行为未定义。


## 15. A继承了B，A的sizeof大小有多少

https://www.cnblogs.com/alexhg/p/6552645.html

类A的大小将是类B的大小加上类A自己的大小。如果类A没有添加任何新的成员变量或函数，则类A的大小将等于类B的大小。