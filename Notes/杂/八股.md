## 1. STL六大组件

- Container(容器)：各种数据结构，如Vector,List,Deque,Set,Map,用来存放数据，STL容器是一种Class Template,就体积而言，这一部分很像冰山载海面的比率。

- Adapter(适配器)：一种用来修饰容器（Containers）或仿函数（Functors）或迭代器（Iterators）接口的东西，例如：STL提供的Queue和Stack，虽然看似容器，其实只能算是一种容器配接器，因为 它们的底部完全借助Deque，所有操作有底层的Deque供应。改变Functor接口者，称为Function Adapter;改变Container接口者，称为Container Adapter;改变Iterator接口者，称为Iterator Adapter。配接器的实现技术很难一言蔽之，必须逐一分析。

- Algorithm(算法)：各种常用算法如Sort,Search,Copy,Erase,从实现的角度来看，STL算法是一种Function Templates。

- Iterator(迭代器)：扮演容器与算法之间的胶合剂，是所谓的“泛型指针”，共有五种类型，以及其它衍生变化，从实现的角度来看，迭代器是一种将：Operators*,Operator->,Operator++,Operator--等相关操作予以重载的Class Template。所有STL容器都附带有自己专属的迭代器——是的，只有容器设计者才知道如何遍历自己的元素，原生指针（Native pointer）也是一种迭代器。

- Function object(函数对象)：行为类似函数，可作为算法的某种策略（Policy），从实现的角度来看，仿函数是一种重载了Operator()的Class 或 Class Template。一般函数指针可视为狭义的仿函数。

- Allocator(分配器)：负责空间配置与管理，从实现的角度来看，配置器是一个实现了动态空间配置、空间管理、空间释放的Class Template。


## 2. 红黑树删除节点原理

红黑树（Red Black Tree）是一颗自平衡（self-balancing）的二叉排序树（BST），树上的每一个结点都遵循下面的规则（特别提醒，这里的自平衡和平衡二叉树AVL的高度平衡有别）：

1. 每一个结点都有一个颜色，要么为红色，要么为黑色；
2. 树的根结点为黑色；
3. 树中不存在两个相邻的红色结点（即红色结点的父结点和孩子结点均不能是红色）；
4. 从任意一个结点（包括根结点）到其任何后代 NULL 结点（默认是黑色的）的每条路径都具有相同数量的黑色结点。

- 为什么要有红黑树？

    大多数二叉排序树BST的操作（查找、最大值、最小值、插入、删除等等）都是 O(h) 的时间复杂度，h 为树的高度。
    但是对于斜树而言（BST极端情况下出现），BST的这些操作的时间复杂度将达到  O(n)。
    为了保证BST的所有操作的时间复杂度的上限为 O(logn) ，就要想办法把一颗BST树的高度一直维持在 logn. 而红黑树就做到了这一点，红黑树的高度始终都维持在 logn ，n 为树中的顶点数目.

- 红黑树RBT与平衡二叉树AVL比较：

    AVL 树比红黑树更加平衡，但AVL树在插入和删除的时候也会存在大量的旋转操作。所以当你的应用涉及到频繁的插入和删除操作，切记放弃AVL树，选择性能更好的红黑树；当然，如果你的应用中涉及的插入和删除操作并不频繁，而是查找操作相对更频繁，那么就优先选择 AVL 树进行实现。

- 一颗红黑树是如何保持平衡的？
    https://cloud.tencent.com/developer/article/1794165

引理：一棵有n个内部结点的红黑树的高度 h <= 2lg(n+1)。

## 3. 听说过右值引用吗，说一下功能

C++11 之前，只有 copy 语意，这对于极度关注性能的语言而言是一个重大的缺失。那时候程序员为了避免性能损失， 只好采取规避的方式。比如:

```cpp
std::string str = s1;
str += s2;
```

这种写法就可以规避不必要的拷贝。而更加直观的写法：

```cpp
std::string str = s1 + s2;
```

则必须忍受一个 s1 + s2 所导致的中间 临时对象 到 str 的拷贝开销。 即便那个中间临时对象随着表达式的结束，会被销毁（更糟的是，销毁所伴随的资源释放，也是一种性能开销）。

对于 move 语意的急迫需求，到了 C++11 终于被引入。其直接的驱动力很简单：在构造或者赋值时， 如果等号右侧是一个中间临时对象，应直接将其占用的资源直接 move 过来（对方就没有了）。

详情看Rvalue.md以及Understanding Modern C++。

## 4. 说一说new和malloc的区别

1. 属性的区别

    new/delete：这两个是C++中的关键字，若要使用，需要编译器支持；

    malloc/free：这两个是库函数，若要使用则需要引入相应的头文件才可以正常使用。

2. 使用上的区别

    malloc：申请空间需要显式填入申请内存的大小；

    new：无需显式填入申请的内存大小，new会根据new的类型分配内存。

    ```cpp
    /** malloc/free用例 **/
    int* ma = (int*) malloc(4)；
    free(ma)；
    /** new/delete用例 **/
    int* ne = newint(0);
    ```

3. 内存位置的区别

    new：此操作符分配的内存空间是在自由存储区(free store)；

    malloc：申请的内存是在堆空间。

    C/C++的内存通常分为：堆、栈、自由存储区、全局/静态存储区、常量存储区。可能除了自由存储区，其他的内存分布大家应该都比较熟悉。

    堆 是C语言和操作系统的术语，堆是操作系统所维护的一块特殊内存，它提供了动态分配的功能，当运行程序调用malloc()时就会从中分配，调用free()归还内存。那什么是自由存储区呢？

    自由存储区 是C++中动态分配和释放对象的一个概念，通过new分配的内存区域可以称为自由存储区，通过delete释放归还内存。自由存储区可以是堆、全局/静态存储区等，具体是在哪个区，主要还是要看new的实现以及C++编译器默认new申请的内存是在哪里。但是基本上，很多C++编译器默认使用堆来实现自由存储，运算符new和delete内部默认是使用malloc和free的方式来被实现，说它在堆上也对，说它在自由存储区上也正确。因为在C++中new和delete符号是可以重载的，我们可以重新实现new的实现代码，可以让其分配的内存位置在静态存储区等。而malloc和free是C里的库函数，无法对其进行重载。

4. 返回类型的区别

    new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void*，需要通过强制类型转换将void*指针转换成我们需要的类型。所以在C++程序中使用new会比malloc安全可靠。

5. 分配失败情况的区别

    malloc分配内存失败时返回NULL，我们可以通过判断返回值可以得知是否分配成功；

    new内存分配失败时，会抛出bad_alloc异常，它不会返回NULL，分配失败时如果不捕捉异常，那么程序就会异常退出，我们可以通过异常捕捉的方式获取该异常。

6. 定义对象系统调度过程的区别

    使用new操作符来分配对象内存时会经历三个步骤：

    调用operator new 函数（对于数组是operator new[]）分配一块足够的内存空间（通常底层默认使用malloc实现，除非程序员重载new符号）以便存储特定类型的对象；

    编译器运行相应的构造函数以构造对象，并为其传入初值。

    对象构造完成后，返回一个指向该对象的指针。

    使用delete操作符来释放对象内存时会经历两个步骤：

    调用对象的析构函数。

    编译器调用operator delete(或operator delete[])函数释放内存空间（通常底层默认使用free实现，除非程序员重载delete符号）。

    自己可以通过实例去验证下，此处就不展开例程了。

7. 扩张内存大小的区别

    malloc：使用malloc分配内存后，发现内存不够用，那我们可以通过realloc函数来扩张内存大小，realloc会先判断当前申请的内存后面是否还有足够的内存空间进行扩张，如果有足够的空间，那么就会往后面继续申请空间，并返回原来的地址指针；否则realloc会在另外有足够大小的内存申请一块空间，并将当前内存空间里的内容拷贝到新的内存空间里，最后返回新的地址指针。

    new：new没有扩张内存的机制。


## 5. 引用占内存吗

一般C++的教材中都是这么定义的：

1. 引用就是一个对象的别名。
2. 引用不是值不占内存空间。
3. 引用必须在定义时赋值，将变量与引用绑定。

这里给出引用的本质定义

1. 引用实际是通过指针实现的。
2. 引用是一个指针常量。
3. 引用在内存中占4个字节(占用内存和cpu位数有关系 64位系统是8个字节)。因为指针存的是地址，所以和地址总线的位数有关。
4. 在对引用定义时，需要对这个常量指针初始化。

引用只是编译器之上，给出来的一个抽象定义。接口的实现，由编译器来决定！

引用不占空间意思就是不占对象空间，不表示不占指针的少量空间。实际上指针是汇编工具实现引用的一种方式而已，而有的优化结果可能没有代表自己的指针。

总而言之，引用就是引用，是这种概念，它为方便程序员使用，和方便汇编工具优化而产生。汇编怎么实现和优化是汇编的事，至于出了什么违反该概念的结果，是汇编的错，而不是定义的错，不要本末倒置。

## 6. 手写一个智能指针

考察面试人员的基本功（考察类的写法，构造\拷贝构造\赋值\移动构造\运算符重载等）。

1. Shared_ptr

注意:

- 对于构造函数，我们仿照了shared_ptr的源代码，加入了explicit关键字，防止原始指针隐式的转化为智能指针。
- 传入空指针或者使用默认构造函数时，引用计数为0。
- 拷贝赋值函数需要检查自赋值的情况。
- 释放动态内存时时刻注意两个指针是不是空指针。

- Shared_ptr将一个计数器与类指向的对象相关联，引用计数跟踪该类有多少个对象共享同一指针。每次创建类的新对象时，初始化指针并将引用计数置为1；

- 当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数；

- 对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数；

- 调用析构函数时，构造函数减少引用计数（如果引用计数减至0，则自动删除所指向的堆内存；

```cpp
template<typename T>
class SharedPtr()
{
public:
    explicit SharedPtr();
    explicit SharedPtr(T *_ptr);
    SharedPtr(const SharedPtr& p);  // 拷贝构造函数
    // 拷贝赋值运算符(左边的值减少，右边的值增加)
    SharedPtr& operator=(const SharedPtr& p);
    ~SharedPtr();

    
    // 解引用运算符
    T& operator*();
    // 箭头运算符
    T* operator->();
    // 重载布尔值操作
    operator bool();

    T* get() const;

    size_t use_count();

    bool isUnique();

    void swap(SharedPtr& p);

private:
    size_t* count;
    T* ptr;
};

template<typename T>
SharedPtr<T>::SharedPtr() : count(new size_t(0)), ptr(nullptr)
{}

template<typename T>
SharedPtr<T>::SharedPtr(T *_ptr) : count(new size_t(1)), ptr(_ptr)
{}

template<typename T>
SharedPtr<T>::~SharedPtr()
{
    --(*count);
    if(*count <= 0) {
        delete ptr;
        delete count;
        ptr = nullptr;
        count = nullptr;
    }
    std::cout << "Shared ptr destroyed." << std::endl;
}

template<typename T>
SharedPtr<T>::SharedPtr(const SharedPtr &p)
{
    count = p.count;
    ptr = p.ptr;
    ++(*count);
}

template<typename T>
SharedPtr<T>& SharedPtr<T>::operator=(const SharedPtr &p)
{
    // 如果是原指针，直接返回
    if(ptr == p.ptr) {
        return *this;
    }

    if(ptr) {
        --(*count);
        if((*count) == 0) {
            delete ptr;
            delete count;
        }
    }

    ptr = p.ptr;
    count = p.count;
    ++(*count);
    return *this;
}

template<typename T>
T& SharedPtr<T>::operator*()
{
    return *ptr;
}

template<typename T>
T* SharedPtr<T>::operator->()
{
    return ptr;
}

template<typename T>
SharedPtr<T>::operator bool()
{
    return ptr != nullptr;
}

template<typename T>
T* SharedPtr<T>::get() const
{
    return ptr;
}

template<typename T>
size_t SharedPtr<T>::use_count()
{
    return *count;
}

template<typename T>
bool SharedPtr<T>::isUnique()
{
    return *count == 1;
}

template<typename T>
void SharedPtr<T>::swap(SharedPtr& p)
{
    std::swap(*this, p);
}

```

2. Unique_ptr

- unique_ptr“唯一”拥有其所指对象，同一时刻只能有一个unique_ptr指向给定对象（通过禁止拷贝语义、只有移动语义来实现）。相比与原始指针unique_ptr用于其RAII的特性，使得在出现异常的情况下，动态资源能得到释放。

- unique_ptr指针本身的生命周期：从unique_ptr指针创建时开始，直到离开作用域。离开作用域时，若其指向对象，则将其所指对象销毁(默认使用delete操作符，用户可指定其他操作)。

- unique_ptr指针与其所指对象的关系：在智能指针生命周期内，可以改变智能指针所指对象，如创建智能指针时通过构造函数指定、通过reset方法重新指定、通过release方法释放所有权、通过移动语义转移所有权。


3. Weak_ptr

- weak_ptr是一种不控制对象生命周期的智能指针，它指向一个 shared_ptr 管理的对象。进行该对象的内存管理的是那个强引用的 shared_ptr，weak_ptr只是提供了对管理对象的一个访问手段。

- weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作，它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。


7. 流水线与冒险

Pipeline Hazards
https://zhuanlan.zhihu.com/p/447682231


8. Shared_ptr循环引用的例子? 

Boy类中有Girl的智能指针；
Girl类中有Boy的智能指针；
当他们交叉互相持有对方的管理对象;

```cpp
#include <iostream>
#include <string>
#include <memory>

using namespace std;

class Girl;

class Boy {
public:
	Boy() {
		cout << "Boy 构造函数" << endl;
	}

	~Boy() {
		cout << "~Boy 析构函数" << endl;
	}

	void setGirlFriend(shared_ptr<Girl> _girlFriend) {
		this->girlFriend = _girlFriend;
	}

private:
	shared_ptr<Girl> girlFriend;
};

class Girl {
public:
	Girl() {
		cout << "Girl 构造函数" << endl;
	}

	~Girl() {
		cout << "~Girl 析构函数" << endl;
	}

	void setBoyFriend(shared_ptr<Boy> _boyFriend) {
		this->boyFriend = _boyFriend;
	}

private:
	shared_ptr<Boy> boyFriend;
};


void useTrap() {
	shared_ptr<Boy> spBoy(new Boy());
	shared_ptr<Girl> spGirl(new Girl());

	// 陷阱用法
	spBoy->setGirlFriend(spGirl);
	spGirl->setBoyFriend(spBoy);
	// 此时boy和girl的引用计数都是2
}


int main(void) {
	useTrap();

	system("pause");
	return 0;
}
```

程序结束了，但是并没有释放内存，这是为什么呢？？？
useTrap函数结束后，函数中定义的智能指针被清掉，boy和girl指针的引用计数减1，还剩下1，对象中的智能指针还是托管他们的，所以函数结束后没有将boy和gilr指针释放的原因就是于此。

有办法解决的，那就是使用weak_ptr弱指针。

另一种情况。如果是单方获得管理对方的共享指针，那么这样着是可以正常释放掉的！

```cpp
void useTrap() {
	shared_ptr<Boy> spBoy(new Boy());
	shared_ptr<Girl> spGirl(new Girl());

	// 单方获得管理
	//spBoy->setGirlFriend(spGirl);
	spGirl->setBoyFriend(spBoy);	
}
```

首先释放spBoy，但是因为girl对象里面的智能指针还托管着boy，boy的引用计数为2，所以释放spBoy时，引用计数减1，boy的引用计数为1；

在释放spGirl，girl的引用计数减1，为零，开始释放girl的内存，因为girl里面还包含有托管boy的智能指针对象，所以也会进行boyFriend的内存释放，boy的引用计数减1，为零，接着开始释放boy的内存。最终所有的内存都释放了。


```cpp
weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。 同时weak_ptr 没有重载*和->但可以使用 lock 获得一个可用的 shared_ptr 对象。

弱指针的使用；

```cpp
weak_ptr wpGirl_1; // 定义空的弱指针

weak_ptr wpGirl_2(spGirl); // 使用共享指针构造

wpGirl_1 = spGirl; // 允许共享指针赋值给弱指针

// 弱指针也可以获得引用计数；

wpGirl_1.use_count()

// 弱指针不支持 * 和 -> 对指针的访问；
```

在必要的使用可以转换成共享指针 lock()；

```cpp
shared_ptr<Girl> sp_girl;
sp_girl = wpGirl_1.lock();

// 使用完之后，再将共享指针置NULL即可
sp_girl = NULL;
```


```cpp
#include <iostream>
#include <string>
#include <memory>

using namespace std;

class Girl;

class Boy {
public:
	Boy() {
		cout << "Boy 构造函数" << endl;
	}

	~Boy() {
		cout << "~Boy 析构函数" << endl;
	}

	void setGirlFriend(shared_ptr<Girl> _girlFriend) {
		this->girlFriend = _girlFriend;


		// 在必要的使用可以转换成共享指针
		shared_ptr<Girl> sp_girl;
		sp_girl = this->girlFriend.lock();

		cout << sp_girl.use_count() << endl;
		// 使用完之后，再将共享指针置NULL即可
		sp_girl = NULL;
	}

private:
	weak_ptr<Girl> girlFriend;
};

class Girl {
public:
	Girl() {
		cout << "Girl 构造函数" << endl;
	}

	~Girl() {
		cout << "~Girl 析构函数" << endl;
	}

	void setBoyFriend(shared_ptr<Boy> _boyFriend) {
		this->boyFriend = _boyFriend;
	}

private:
	shared_ptr<Boy> boyFriend;
};


void useTrap() {
	shared_ptr<Boy> spBoy(new Boy());
	shared_ptr<Girl> spGirl(new Girl());

	spBoy->setGirlFriend(spGirl);
	spGirl->setBoyFriend(spBoy);
}


int main(void) {
	useTrap();

	system("pause");
	return 0;
}

/*
Boy 构造函数
Girl 构造函数
3
~Girl 析构函数
~Boy 析构函数
*/
```

expired：判断当前weak_ptr智能指针是否还有托管的对象，有则返回false，无则返回true

如果返回true，等价于 use_count() == 0，即已经没有托管的对象了；当然，可能还有析构函数进行释放内存，但此对象的析构已经临近（或可能已发生）。

```cpp
#include <iostream>
#include <memory>

std::weak_ptr<int> gw;

void f() {

	// expired：判断当前智能指针是否还有托管的对象，有则返回false，无则返回true
	if (!gw.expired()) {
		std::cout << "gw is valid\n";	// 有效的，还有托管的指针
	} else {
		std::cout << "gw is expired\n";	// 过期的，没有托管的指针
	}
}

int main() {
	{
		auto sp = std::make_shared<int>(42);
		gw = sp;

		f();
	}

	// 当{ }体中的指针生命周期结束后，再来判断其是否还有托管的指针
	f();

	return 0;
}

/*
gw is valid
gw is expired
*/
```


## 9. Vector自动扩容、缩容?

和数组类似，也称为单端数组

不同之处在于数组是静态空间，vector可以动态扩展

动态扩展：并不是在原空间后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间

vector 的迭代器支持随机访问


// 头部插入删除：O(N)

// 尾部插入删除:O(1)

// 中间插入删除：O(N)

// 查找：O(N)

在C++标准库容器vector的容量是不会自动的缩减的，也就是说删除元素操作，其引用、指针、迭代器也会继续有效。那么当在一个较大的vector中删除了大量的元素之后，其实际的size比较小，而其capacity比较大，如果对空间比较敏感，希望vector的容量能够缩小一些，这时可以使用下面的技巧来实现。

```cpp
std::vector<T> tmp(v);
tmp.swap(v);
```

```cpp
std::vector<T>(v1).swap(v1);
```

## 10. 生产者-消费者问题

生产者消费者问题（英語：Producer-consumer problem），也称有限缓冲问题（Bounded-buffer problem），是一个多进程同步问题的经典案例。 该问题描述了共享固定大小缓冲区的两个进程——即所谓的“生产者”和“消费者”——在实际运行时会发生的问题。

- 单生产者和单消费者

    有两个进程：一组生产者进程和一组消费者进程共享一个初始为空、固定大小为n的缓存（缓冲区）。生产者的工作是制造一段数据，只有缓冲区没满时，生产者才能把消息放入到缓冲区，否则必须等待，如此反复; 同时，只有缓冲区不空时，消费者才能从中取出消息，一次消费一段数据（即将其从缓存中移出），否则必须等待。由于缓冲区是临界资源，它只允许一个生产者放入消息，或者一个消费者从中取出消息。

    **问题的核心**是：

        1.要保证不让生产者在缓存还是满的时候仍然要向内写数据;

        2.不让消费者试图从空的缓存中取出数据。

    生产者和消费者对缓冲区互斥访问是互斥关系，同时生产者和消费者又是一个相互协作的关系，只有生产者生产之后，消费者才能消费，他们也是同步关系。

    **解决思路**：对于生产者，如果缓存是满的就去睡觉。消费者从缓存中取走数据后就叫醒生产者，让它再次将缓存填满。若消费者发现缓存是空的，就去睡觉了。下一轮中生产者将数据写入后就叫醒消费者。不完善的解决方案会造成“死锁”，即两个进程都在“睡觉”等着对方来“唤醒”。

    只有生产者和消费者两个进程，正好是这两个进程存在着互斥关系和同步关系。那么需要解决的是互斥和同步PV操作的位置。使用“进程间通信”，“信号标”semaphore就可以解决唤醒的问题：

        我们使用了两个信号标：full 和 empty 。信号量mutex作为互斥信号量，它用于控制互斥访问缓冲池，互斥信号量初值为 1；信号量 full 用于记录当前缓冲池中“满”缓冲区数，初值为0。信号量 empty 用于记录当前缓冲池中“空”缓冲区数，初值为n。新的数据添加到缓存中后，full 在增加，而 empty 则减少。如果生产者试图在 empty 为0时减少其值，生产者就会被“催眠”。下一轮中有数据被消费掉时，empty就会增加，生产者就会被“唤醒”。

    ```cpp
    semaphore mutex=1; //临界区互斥信号量
    semaphore empty=n;  //空闲缓冲区
    semaphore full=0;  //缓冲区初始化为空
    producer ()//生产者进程 
    {
        while(1)
        {
            produce an item in nextp;  //生产数据
            P(empty);  //获取空缓冲区单元
            P(mutex);  //进入临界区.
            add nextp to buffer;  //将数据放入缓冲区
            V(mutex);  //离开临界区,释放互斥信号量
            V(full);  //满缓冲区数加1
        }
    }

    consumer ()//消费者进程
    {
        while(1)
        {
            P(full);  //获取满缓冲区单元
            P(mutex);  // 进入临界区
            remove an item from buffer;  //从缓冲区中取出数据
            V (mutex);  //离开临界区，释放互斥信号量
            V (empty) ;  //空缓冲区数加1
            consume the item;  //消费数据
        }
    }
    ```

    该类问题要注意对缓冲区大小为n的处理，当缓冲区中有空时便可对empty变量执行P 操作，一旦取走一个产品便要执行V操作以释放空闲区。对empty和full变量的P操作必须放在对mutex的P操作之前。


## 11. Cpp 在Linux中的内存布局，为什么BSS段每次都要清零

BSS段我所知道的起源是Unix最初的时候（当然，不排除可能有更早的情况）。变量分两种：局部变量、全局变量。

根据C语法的规定，局部变量不设置初始值的时候，其初始值是不确定的，局部变量（不含静态局部变量）的存储位置位于栈上，具体位置不固定。

全局变量（和静态局部变量）有专门数据段存储，初始值是0，具体位置是固定的。

其实说到底，就两种，一种是位置固定（数据段里），一种是位置不固定的（栈上）。 

要知道，早期的计算机存储设备是很贵的，而很多时候，数据段里的全局变量都是0（或者没有初始值），那么存储这么多的0到目标文件里其实是没有必要的。所以为了节约空间，在生成目标文件的时候，就把没有初始值（实际就是0）的数据段里的变量都放到BSS段里，这样目标文件就不需要那么大的体积里（节约磁盘空间）。只有当目标文件被载入的时候，加载器负责把BSS段清零（一个循环就可以搞定）。 之后，这个规则慢慢的成为一个标准配置，大多数编译器也就都支持了BSS段。

解释几个问题：

- Q:为什么局部变量初始值不是0？ 
    
    A:局部变量初始值也可以是零（在某些语言中就是），但这实际上需要消耗硬件指令去完成，有些时候这种清零的动作意义不大，对于编译器来说也是一种负担，每次调用函数都要消耗指令去清零，负担太大。要知道全局变量在内存中只有一份，局部变量（非静态）可以是多份的，前者一次清零就可以了，后者多次清零，负担太大。 

    C语言中，未初始化的局部变量到底是多少？

    答案往往是：

        - 与编译器有关。
        - 可能但不保证初始化为0。
        - 未确定。

    CPU不认识变量，更无法识别变量的名字，CPU只会从特定的内存位置取值或者将值存到特定的内存位置，因此当问一个变量的值是多少的时候，必须要知道这个变量对应的值被保存在什么地方。

    ```cpp
    #include <stdio.h>

    void func1()
    {
        int a;
        printf("func1:%d\n", a);
        a = 12345;
    }

    void func2()
    {
        int b;
        printf("func2:%d\n", b);
    }

    void func4()
    {
        int d;
        printf("func3:%d\n", d);
    }

    void func3()
    {
        int c;
        printf("func3:%d\n", c);
        c = 54321;
        func4();
    }

    void test_call()
    {
        func3();
    }

    int main(int argc, char **argv)
    {
        func1();
        func2();

        test_call();
    }

    ```

    **总结：函数返回在pop出当前栈帧的时候，并不会清理它遗留在栈帧里的数据，下个函数调用再次重用到该栈帧的内存时，未初始化的局部变量将会被遗留数据影响，从而变得不确定！**

    所以，记得初始化你的局部变量。

- Q: 如果BSS不清零可不可以？ 

    A: 可以，如果编译器规定BSS段不清零，也是可以的，但这样的话C语言语法就要改了：未初始化的全局变量和静态局部变量，其值是未知的。甚至其它语言也要跟着改语法。 

- Q: BSS段清零的原因是因为这个段是BSS 现在存储介质这么便宜了，是不是BSS已经没有必要了？

    A: 当然不是了，介质便宜仅限于PC和数码产品这一块，嵌入式行业永远都不存在存储介质没有限制的情况。

## 12. 一个没有成员变量的类，sizeof大小是多少？

sizeof(空类/空结构体) = 1；

空类，没有任何成员变量或函数，即没有存储任何内容；但是由于空类仍然可以实例化，例如：

```cpp
ClassA A;  
cout << "sizeof(A): " << sizeof(A) << endl; 
```

一个类能够实例化，编译器就需给它分配内存空间，来指示类实例的地址。这里编译器默认分配了一个字节（如：char. C char是1个字节，因为它是在标准中指定的, 最可能的逻辑是, char (标准字符集)的(二进制)表示可以适合1个字节。 在C的主要开发时，最常用的标准是ASCII和EBCDIC ，它们分别需要7位和8位编码。），以便标记可能初始化的类实例，同时使空类占用的空间也最少（即1字节）。这是被编译器安插进去的一个字节，这样就使得这个空类的两个实例得以在内存中配置独一无二的地址。


## 13. 什么是内存对齐？为什么要？C++怎么调整内存对齐大小？


1. 什么是内存对齐

    还是用一个例子带出这个问题，看下面的小程序，理论上，32位系统下，int占4byte，char占一个byte，那么将它们放到一个结构体中应该占4+1=5byte；但是实际上，通过运行程序得到的结果是8 byte，这就是内存对齐所导致的。

    ```cpp
    //32位系统
    #include<stdio.h>
    struct{
        int x;
        char y;
    }s;

    int main()
    {
        printf("%d\n",sizeof(s);  // 输出8
        return 0;
    }
    ```

    现代计算机中内存空间都是按照 byte 划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但是实际的计算机系统对基本类型数据在内存中存放的位置有限制，它们会要求这些数据的首地址的值是某个数k（通常它为4或8）的倍数，这就是所谓的内存对齐。

2. 为什么要进行内存对齐

    尽管内存是以字节为单位，但是大部分处理器并不是按字节块来存取内存的.它一般会以双字节,四字节,8字节,16字节甚至32字节为单位来存取内存，我们将上述这些存取单位称为内存存取粒度.

    现在考虑4字节存取粒度的处理器取int类型变量（32位系统），该处理器只能从地址为4的倍数的内存开始读取数据。

    假如没有内存对齐机制，数据可以任意存放，现在一个int变量存放在从地址1开始的连续四个字节地址中，该处理器去取数据时，要先从0地址开始读取第一个4字节块,剔除不想要的字节（0地址）,然后从地址4开始读取下一个4字节块,同样剔除不要的数据（5，6，7地址）,最后留下的两块数据合并放入寄存器.这需要做很多工作.

    现在有了内存对齐的，int类型数据只能存放在按照对齐规则的内存中，比如说0地址开始的内存。那么现在该处理器在取数据时一次性就能将数据读出来了，而且不需要做额外的操作，提高了效率。

3. 规则

    每个特定平台上的编译器都有自己的默认“对齐系数”（也叫对齐模数）。gcc中默认#pragma pack(4)，可以通过预编译命令#pragma pack(n)，n = 1,2,4,8,16来改变这一系数。

    有效对其值：是给定值#pragma pack(n)和结构体中最长数据类型长度中较小的那个。有效对齐值也叫对齐单位。

    了解了上面的概念后，我们现在可以来看看内存对齐需要遵循的规则：

    (1) 结构体第一个成员的偏移量（offset）为0，以后每个成员相对于结构体首地址的 offset 都是该成员大小与有效对齐值中较小那个的整数倍，如有需要编译器会在成员之间加上填充字节。

    (2) 结构体的总大小为 有效对齐值 的整数倍，如有需要编译器会在最末一个成员之后加上填充字节。

    ```cpp
    // 32位系统
    // Linux环境下进行的，linux下默认#pragma pack(4)，且结构体中最长的数据类型为4个字节，所以有效对齐单位为4字节
    #include<stdio.h>
    struct
    {
        int i;    
        char c1;  
        char c2;  
    }x1;

    struct{
        char c1;  
        int i;    
        char c2;  
    }x2;

    struct{
        char c1;  
        char c2; 
        int i;    
    }x3;

    int main()
    {
        printf("%d\n",sizeof(x1));  // 输出8
        printf("%d\n",sizeof(x2));  // 输出12
        printf("%d\n",sizeof(x3));  // 输出8
        return 0;
    }
    ```

## 14. 什么函数不能声明为virtual？为什么构造函数一定不能为virtual？有virtual方法的类，为什么析构函数一定是virtual？

在C++中，除了构造函数和静态成员函数，其他所有成员函数都可以声明为虚函数。

构造函数不能声明为虚函数，因为在创建对象时，必须知道对象的确切类型，以便正确地调用相应的构造函数。当类中声明虚函数时，编译器会在类中生成一个虚函数表，虚函数表是一个存储成员函数指针的数据结构。虚函数表是由编译器自动生成与维护的，virtual成员函数会被编译器放入虚函数表中，当存在虚函数时，每个对象都有一个指向虚函数的指针（vptr指针）。在实现多态的过程中，父类和派生类都有vptr指针。

vptr的初始化：当对象在创建时，由编译器对vptr指针进行初始化。在定义子类对象时，vptr先指向父类的虚函数表，在父类构造完成之后，子类的vptr才指向自己的虚函数表。（也就是说当子类构造时，编译器会将父类的虚函数表复制到子类中。因此，子类构造完后，就会有父类的虚函数表。如果子类没有重写父类的任何虚函数，那么子类的虚函数表和父类的虚函数表完全相同。如果子类重写了父类的某些虚函数，那么子类的虚函数表会在重写的虚函数处进行修改。）如果构造函数是虚函数，那么调用构造函数就需要去找vptr，而此时vptr还没有初始化（还没到创建的时候呢）。因此，构造函数不可以是虚函数。

析构函数应该声明为虚函数，因为在使用基类指针指向派生类对象并删除基类指针时，如果析构函数不是虚拟的，只会调用基类的析构函数，而不会调用派生类的析构函数，这可能导致资源泄漏或行为未定义。

https://zhuanlan.zhihu.com/p/75172640


## 15. A继承了B，A的sizeof大小有多少

https://www.cnblogs.com/alexhg/p/6552645.html

类A的大小将是类B的大小加上类A自己的大小。如果类A没有添加任何新的成员变量或函数，则类A的大小将等于类B的大小。

## 16. 多态有几种，如何实现？

1) 静态多态（重载，模板）

    是在编译的时候，就确定调用函数的类型。

2) 动态多态（覆盖，虚函数实现）

    在运行的时候，才确定调用的是哪个函数，动态绑定。运行基类指针指向派生类的对象，并调用派生类的函数。

    虚函数实现原理：虚函数表和虚函数指针。

    纯虚函数： virtual int fun() = 0;

引用一下 Charlie Calverts的对多态的描述吧——多态性是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。

简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。多态性在Object Pascal和C++中都是通过虚函数（Virtual Function） 实现的。 

好，接着是"虚函数"（或者是"虚方法"）。虚函数就是允许被其子类重新定义的成员函数。而子类重新定义父类虚函数的做法，称为"覆盖"（override），或者称为"重写"。

这里有一个初学者经常混淆的概念。覆盖（override）和重载（overload）。

上面说了，覆盖是指子类重新定义父类的虚函数的做法。而重载，是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。其实，重载的概念并不属于"面向对象编程"，重载的实现是：编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数（至少对于编译器来说是这样的）。如，有两个同名函数：function func(p:integer):integer;和function func(p:string):integer;。那么编译器做过修饰后的函数名称可能是这样的：int_func、str_func。对于这两个函数的调用，在编译器间就已经确定了，是静态的（记住：是静态）。也就是说，它们的地址在编译期就绑定了（早绑定），因此，重载和多态无关！

真正和多态相关的是 "覆盖"。当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针，动态（记住：是动态！）的调用属于子类的该函数，这样的函数调用在编译期间是无法确定的（调用的子类的虚函数的地址无法给出）。 
因此，这样的函数地址是在运行期绑定的（晚邦定）。结论就是：重载只是一种语言特性，与多态无关，与面向对象也无关！ 

那么，多态的作用是什么呢？我们知道，封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）；它们的目的都是为了——代码重用。

而多态则是为了实现另一个目的——接口重用！而且现实往往是，要有效重用代码很难，而真正最具有价值的重用是接口重用，因为"接口是公司最有价值的资源。设计接口比用一堆类来实现这个接口更费时间。而且接口需要耗费更昂贵的人力的时间。" 

其实，继承的为重用代码而存在的理由已经越来越薄弱，因为"组合"可以很好的取代继承的扩展现有代码的功能，而且"组合"的表现更好（至少可以防止"类爆炸"）。因此笔者个人认为，继承的存在很大程度上是作为"多态"的基础而非扩展现有代码的方式了。

成员函数被重载的特征有：

1) 相同的范围（在同一个类中）；

2) 函数名字相同；

3) 参数不同；

4) virtual关键字可有可无。

覆盖的特征有：

1) 不同的范围（分别位于派生类与基类）；

2) 函数名字相同；

3) 参数相同；

4) 基类函数必须有virtual关键字。

隐藏是指派生类的函数屏蔽了与其同名的基类函数，规则如下：

1) 如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。

2) 如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）。

## 17. 被重载的函数怎么知道该执行哪个的？

重载，是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。其实，重载的概念并不属于"面向对象编程"，重载的实现是：编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数（至少对于编译器来说是这样的）。如，有两个同名函数：function func(p:integer):integer;和function func(p:string):integer;。那么编译器做过修饰后的函数名称可能是这样的：int_func、str_func。对于这两个函数的调用，在编译器间就已经确定了，是静态的（记住：是静态）。也就是说，它们的地址在编译期就绑定了（早绑定）。

因而，当你的代码中出现 函数调用 时，编译器需要弄明白，此 函数调用 究竟调用的是那个版本。而这个弄明白的过程， 被称作 Overload Resolution ( 重载决议 / 重载解析) 。

1. 编译器首先会根据 C++ 规范所定义的 名字查找 规则，找到所有符合名字查找规则的同名函数，作为 候选集 。如果 候选集 为空，编译器直接报错。

2. 将明确不匹配的版本（比如参数个数不匹配）踢出 候选集 。

3. 如果剩余的 候选集 里存在 函数模版 ，则需要对 模版参数 进行推演（如果调用时用户没有全部明确指定的话）。 如果类型推演失败，则将此函数模版移出 候选集 。 如果类型推演成功，则将指定的，或推演出的类型，对模版参数进行 替换 （ Substitution ）。 SFINAE 正是发生在这个环节：如果替换失败，编译器不会给出任何诊断信息，只是简单的将这个 函数模版 踢出 候选集 。如果替换成功，此模版函数 就被实例化为一个普通函数。( 函数模版 自身并不是 函数 )

4. 到这一步依然还剩下的 候选集 ，被称作 viable candidates （ 可行候选集 ）。编译器下一步的任务是从 可行候选集 中 找到 最佳匹配 的版本。而这可能会导致三种结局：

    - 找到了 最佳匹配 版本。编译器将选择这个版本。

    - 可行候选集 为空。这将导致编译错误，编译器会抱怨找不到合适的定义。

    - 存在超过一个 最佳匹配 版本。这会导致 二义性 ，也会造成编译错误。

5. 如果找到了 最佳匹配 版本，编译器还会进行其它检查（可见性，是否被声明为 =delete 等等）。

最佳匹配的规则如下：

1) 如果有一个函数的参数类型比另一个函数的参数类型更精确，那么编译器会选择更精确的函数。
2) 如果有一个函数的参数类型可以隐式转换为另一个函数的参数类型，那么编译器会选择可以进行隐式转换的函数。
3) 如果有多个函数都可以进行隐式转换，那么编译器会选择需要进行最少隐式转换的函数。
4) 如果有多个函数都满足上述条件，那么编译器会选择模板参数最特化的函数。

## 18. 虚表大小

1. 一般情况

    ```cpp

    #include<iostream>
    using namespace std;
    
    
    class base
    {
        public:
        base()=default;
        ~base()=default;
        private:
        static int a;
        int b;
        char c;
    
    };
    
    
    int main()
    {
        base obj;
        cout<<sizeof(obj)<<endl;
    ```

    计算结果：8

    静态变量a不计算在对象的大小内，由于字节对齐，结果为4+4=8。

2. 空类的大小

    空类大小为1

3. 含有虚函数成员的类

    ```cpp
    class Base {
 
    public:
    
    virtual void f() { cout << "Base::f" << endl; }
    
    virtual void g() { cout << "Base::g" << endl; }
    
    virtual void h() { cout << "Base::h" << endl; }
    
    };
    ```

    sizeof(Base)为4，对象中多了一个指向虚函数表的指针，而指针的sizeof是4 (depends)


    每当创建一个包含有虚函数的类或从包含有虚函数的类派生一个类时，编译器就会为这个类创建

    一个虚函数表，保存该类所有虚函数的地址。

    代码示例：

    ```cpp
    class Base {
    
    public:
    
    int a;
    
    virtual void f() { cout << "Base::f" << endl; }
    
    virtual void g() { cout << "Base::g" << endl; }
    
    virtual void h() { cout << "Base::h" << endl; }
    };
    ```

    sizeof(Base)为8。

    vptr指针的大小为4，又因为对象中还包含一个int变量，字节对齐得4+4=8。

4. 多继承下类的大小

    ```cpp
    #include<iostream>
    using namespace std;
    
    
    class A     
    {     
    };    
    
    class B     
    {  
        char ch;     
        virtual void func0()  {  }   
    };   
    
    class C    
    {  
        char ch1;  
        char ch2;  
        virtual void func()  {  }    
        virtual void func1()  {  }   
    };  
    
    class D: public A, public C  
    {     
        int d;     
        virtual void func()  {  }   
        virtual void func1()  {  }  
    };     
    class E: public B, public C  
    {     
        int e;     
        virtual void func0()  {  }   
        virtual void func1()  {  }  
    };  
    
    int main(void)  
    {  
        // sizeof(void*) = 8
        // siezeof(int) = 4
        cout<<"A="<<sizeof(A)<<endl;    //result=1  
        cout<<"B="<<sizeof(B)<<endl;    //result=16      
        cout<<"C="<<sizeof(C)<<endl;    //result=16  
        cout<<"D="<<sizeof(D)<<endl;    //result=16  
        cout<<"E="<<sizeof(E)<<endl;    //result=32  
        return 0;  
    }  
    ```

5. 虚继承的情况

    ```cpp
    class A {
 
        int a;
 
    };
    
    class B: virtual public A{
    
        virtual void myfunB(){}
    
    };
    
    class C: virtual public A{
    
        virtual void myfunC(){}
    
    };
    
    class D: public B,public C{
    
        virtual void myfunD(){}
    
    };
    ```
    A=4
    B=16
    C=16
    D=24

    B，C中由于是虚继承因此大小为int大小加指向虚基类的指针的大小（内存对齐，指针大小为8）。B,C虽然加入了自己的虚函数，但是虚表指针是和基类共享的，因此不会有自己的虚表指针，他们两个共用虚基类A的虚表指针。

## 19. 空指针调用成员函数

1. 是否报错?
    ```cpp
    class A{ static int get {//xxxx} }
    A* a = nullptr;
    a->get();
    ```

    不会报错

2.  空指针可以调用成员函数，不可以调用虚函数。

    因为虚函数是 通过虚函数表来调用的，虚函数表是在构造函数中初始化的，而空指针没有构造函数，所以不能调用虚函数。

    ```cpp
    #include <iostream>
    using namespace std;
    // 空指针可以调用成员函数，不可以调用虚函数。
    class Person {
    public:
        void showClassName() {
            cout << "this is Person class" << endl;
        }

        void showPersonAge() {
            // !解决：
            if (this == NULL)  return;
            cout << "age = " << m_age << endl;
        }

        int m_age;
    };

    void test01() {
        Person* p = NULL;
        p->showClassName(); // 没崩
        p->showPersonAge(); // !崩了，因为编译器默认加了this->在属性前面，而传入的指针是NULL
    }
    ```



## 20. 四种cast区别


static_cast、dynamic_cast、const_cast和reinterpret_cast


C风格转换: 
```
(T)expression;
```

C++风格转换: 
```static_cast<T>(expression);
dynamic_cast<T>(expression);
reinterpret_cast<T>(expression);
const_cast<T>(expression);
```

1. C风格转换

    一般许多书本会建议使用c++提供的四种类型转换而不是使用c风格的转换。

    因为c风格的类型转换有不少的缺点，它可以在任意类型之间转换，比如你可以把一个指向const对象的指针转换成指向非const对象的指针，把一个指向基类对象的指针转换成指向一个派生类对象的指针，这两种转换之间的差别是巨大的，但是传统的c语言风格的类型转换没有区分这些。所以**不够明确，不能进行错误检查**。还有一个缺点就是，c风格的转换**不容易查找**，他由一个括号加上一个标识符组成，而这样的东西在c++程序里一大堆。所以c++为了克服这些缺点，引进了4种新的类型转换操作符。

2. static_cast静态转换

    最常用的转换，但是转换的时候不会检查类型来保证转换的安全性。

    static_cast不能转换掉expression的const、volitale、或者__unaligned属性。

    ```cpp
    class Base{ 
        //.....
    };
    class Derived : public Base{
        //.....
    };
    
    void main()
    {
        //基本类型转换 float -> int
        int i;
        float f = 166.7f;
        i = static_cast<int>(f);
        //子类 -> 父类
        Derived d;
        Base b = static_cast<Base>(d);
        
        //父类 -> 子类
        Base bb;
        Derived* dd = static_cast<Derived>(bb);  //compile error
        Base* pB = new Base;
        Derived* pD = static_cast<Derived*>(pB); //编译通过，但是是不安全的（例如访问子类成员）
    }
    ```

3. dynamic_cast动态转换

    Safely converts pointers and references to classes up, down, and sideways along the inheritance hierarchy.

    dynamic_cast转换操作符在执行类型转换时首先将检查能否成功转换，如果能成功转换则转换之，如果转换失败，如果是指针则反回一个NULL值，如果是转换的是引用，则抛出一个bad_cast异常，所以在使用dynamic_cast转换之间最好使用if语句对其转换成功与否进行测试。

    注意：

    （1）T必须是类的指针、类的引用或者void *。如果T是类指针类型，那么expression也必须是一个指针，如果T是一个引用，那么expression也必须是一个引用。

    （2）dynamic_cast转换符只能用于含有虚函数的类。

    ```cpp

    ```

    dynamic_cast主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换。
    在类层次间进行上行转换（子类->子类/基类）时，dynamic_cast和static_cast的效果是一样的；在进行下行转换（基类->子类）时，dynamic_cast具有类型检查的功能，比static_cast更安全。

4. reinterpret_cast重述转换

    此标识符的意思即为数据的二进制形式重新解释，但是不改变其值。

    (1) T必须是一个指针、引用、算术类型、函数指针或者成员指针。

    (2) 用于将一种类型转换为另一种不同的类型，比如可以把一个整型转换为一个指针，或把一个指针转换为一个整型，因此使用该操作符的危险性较高，一般不应使用该操作符。

    ```cpp
    int i;
    char *p = "This is a example.";
    i = reinterpret_cast<int>(p);   //将指针p的值（即地址）转为int型 【如 0x00b4cd10 -> 11848976】
    ```

5. const_cast转换

    (1) T必须为指针或引用。

    (2) 主要是用来去掉const属性，当然也可以加上const属性。主要是用前者，后者很少用。

    ```cpp

    class A
    {
    public:
        int num;
    };
    
    void main()
    {
        //类指针
        const A a;
        const A* pA = &a; // 常量指针，只能读取内存中内容，不能修改数据的属性
        pA->num = 10;                //compile error
        A* pA2 = const_cast<A*>(pA);
        pA2->num = 11;               //success
    
        //基本数据类型
        const int i = 3;
        int* p = const_cast<int*>(&i);
        *p = 10;                     //success
    
        //加上const属性
        int j = 10;
        const int* k = const_cast<const int*>(&j);//一般可以直接写const int* k = &j;
    }
    ```

## 21. 如何防止CPP程序被编译器编译多次

```cpp
//student.h
class Student {
    //......
};
//school.h
#include "student.h"
class School {
    //......
private:
    Student stu[50];
};
//main.cpp
#include "student.h"
#include "school.h"
int main() {
    //......
    return 0;
}

```

1) 使用宏定义避免重复引入
    
    ```cpp
    #ifndef _NAME_H
    #define _NAME_H
    //头文件内容
    #endif
    ```

    其中，_NAME_H 是宏的名称。需要注意的是，这里设置的宏名必须是独一无二的，不要和项目中其他宏的名称相同。

    当程序中第一次 #include 该文件时，由于 _NAME_H 尚未定义，所以会定义 _NAME_H 并执行“头文件内容”部分的代码；当发生多次 #include 时，因为前面已经定义了 _NAME_H，所以不会再重复执行“头文件内容”部分的代码。

    ```cpp
    #ifndef _STUDENT_H
    #define _STUDENT_H
    class Student {
        //......
    };
    #endif
    ```

2) 使用#pragma once避免重复引入

3) 使用_Pragma操作符

    可以看做是 #pragma 的增强版，不仅可以实现 #pragma 所有的功能，更重要的是，_Pragma 还能和宏搭配使用。

    ```cpp
    _Pragma("once")
    ```

#pragma once 和 _Pragma("once") 可算作一类，其特点是编译效率高，但可移植性差（编译器不支持，会发出警告，但不会中断程序的执行）；而 #ifndef 的特点是可移植性高，编译效率差。

另外在某些场景中，考虑到编译效率和可移植性，#pragma once 和 #ifndef 经常被结合使用来避免头文件被重复引入。比如说：

```cpp
#pragma once
#ifndef _STUDENT_H
#define _STUDENT_H
class Student {
    //......
};
#endif
```

## 23. Include时，""和<>有什么区别
<>符号用于引入系统头文件或全局头文件，而""符号用于引入用户自定义的头文件。 


具体来说，使用<>符号时，C语言编译器会在系统或全局路径中查找头文件；而使用""符号时，编译器则会在当前源文件所在路径下查找头文件。

## 24. 静态链接和动态链接

https://www.runoob.com/w3cnote/cpp-static-library-and-dynamic-library.html

## 25. inline和#define有什么区别？inline一定会被内联上么

- 内联的用处:

#内联函数是指那些定义在类体内的成员函数，即该函数的函数体放在类体内。即以inline修饰的函数，代码被插入调用者代码处，如同C语言中的define。内联函数在编译的时候，会在调用内联函数的地方展开，没有函数栈帧开销，提高程序的运行效率。inline只是对编译器的一个建议，编译器会自动优化。inline修饰函数时，在声明处修饰无效，只有定义函数时使用才行。定义在类内的成员函数默认为内联函数。

- 为什么要引入？

引入内联函数的主要目的是：解决程序中函数调用的效率问题。
另外，前面我们讲到了宏，里面有这么一个例子：
#define ABS(x) ((x)>0? (x):-(x))
当++i出现时，宏就会歪曲我们的意思，换句话说就是：宏的定义很容易产生二意性。

- 什么时候用内联函数？

内联函数在C++类中，应用最广的，应该是用来定义存取函数。我们定义的类中一般会把数据成员定义成私有的或者保护的，这样，外界就不能直接读写我们类成员的数据了。对于私有或者保护成员的读写就必须使用成员接口函数来进行。如果我们把这些读写成员函数定义成内联函数的话，将会获得比较好的效率。

- inline和define的区别:

1.内联在编译期间展开，define在预处理阶段展开。
2.内联会进行，类型检查，define 不会，存在类型安全问题，所以inline会比较安全。
3.inline函数是函数，宏不是函数。
尽量使用const、enum、inline替换#define

- 局限性

函数中的执行代码不能太多了，如果，内联函数的函数体过大，一般的编译器会放弃内联方式，而采用普通的方式调用函数。(换句话说就是，你使用内联函数，只不过是向编译器提出一个申请，编译器可以拒绝你的申请）这样，内联函数就和普通函数执行效率一样了。

## 26. STL常见容器，map和unordered_map

## 27. const关键字几种用法

## 28. static关键字作用？static变量和全局变量区别？

static变量是指静态的变量，不管是在全局还是局部声明的static变量都存放于程序的全局变量区域（Global Data区？），所以它的生命周期是从程序开始到程序结束。但是static变量的作用域并不等同于它的生存周期，它的作用域决定于它被定义的位置。可以认为static变量的作用域<=生存周期。


1. 局部声明静态变量

    ```cpp
    void test(){
        int m = 3;
        static int i = 5;
    }
    ```
    局部变量m存放在栈中，当test函数结束，m将被销毁；静态变量i不存放在栈中，而是存放于程序的全局变量区域，因此随着函数test的结束，它并不随着出栈操作而被销毁，它的生存周期存在于程序的整个运行期；然而m和i的作用域都仅存在于test函数中它们的定义之后，即test调用结束之后，m和i就不再可用，但是i仍存在于内存之中。

    注意：
    (1) 如果static局部变量不初始化，那么它默认为0。
    (2) 如果普通局部变量不初始化，那么它的值为随机数。

2. 全局声明静态变量

    ```cpp
    // 文件A
    int n = 3 // 默认为extern
    static int j = 5; // 声明为static
    ```

    ```cpp
    // 文件B
    extern int n; // OK
    extern int j; // error: j在文件B不可见

    int a = n; // OK
    int b = k; // error
    ```

    全局变量和静态变量都存放于程序的全局数据区域，生存周期都是程序整个运行期。

    但n的作用域为全局作用域，可以通过extern在其他文件中使用。

    j只能在A中使用。


    在声明全局的static变量时，static没有改变它的生命周期（即储存位置，因为全局变量本来就存储在全局数据域），而是将变量作用域限制在了当前文件中。

## 29. 哪些函数不能声明static?

## 30. 手写一下memcpy